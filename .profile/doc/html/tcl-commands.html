<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- $Id: tcl-commands.html,v 1.43 2004/08/02 18:50:47 wcc Exp $ -->

<html>
  <head>
    <title>Eggdrop Documentation: Eggdrop Tcl Commands</title>
  </head>

  <body>
    <div align="center">
      <p><strong>Eggdrop Tcl Commands</strong></p>
    </div>
    <hr>

    <p>This is an exhaustive list of all the Tcl commands added to Eggdrop.
    All of the normal Tcl built-in commands are still there, of course, but
    you can also use these to manipulate features of the bot. They are listed
    according to category.</p>

    <p>This list is accurate for Eggdrop v1.6.17. Scripts written for
    v1.3/v1.4 series of Eggdrop should probably work with a few minor
    modifications depending on the script. Scripts which were written for
    v0.9, v1.0, v1.1 or v1.2 will probably not work without modification.
    Commands which have been changed in this version of Eggdrop (or are
    just new commands) are marked with an asterisk (*).</p>

    <blockquote>
      <ol>
        <li><a href="#output">Output commands</a></li>

        <li><a href="#urmc">User record manipulation commands</a></li>

        <li><a href="#chancmds">Channel commands</a></li>

        <li><a href="#dcccmds">DCC commands</a></li>

        <li><a href="#notes">Notes module</a></li>

        <li><a href="#assoc">Assoc module</a></li>

        <li><a href="#compress">Compress module</a></li>

        <li><a href="#filesys">Filesys module</a></li>

        <li><a href="#misc">Miscellaneous commands</a></li>

        <li><a href="#globvars">Global variables</a></li>

        <li>
          <a href="#bind">Bind</a>

          <ol type="a">
            <li><a href="#binda">Bind types</a></li>

            <li><a href="#bindb">Return values</a></li>
          </ol>
        </li>

        <li><a href="#control">Control procedures</a></li>

        <li><a href="#tcp">TCP connections</a></li>

        <li><a href="#matchchars">Match characters</a></li>
      </ol>
    </blockquote>
    <hr>

    <p><a name="output"></a>1. <strong>Output commands</strong></p>

    <blockquote>
      <dl>
        <dt><strong>putserv &lt;text&gt; [options]</strong></dt>

        <dd>
          <p><strong>Description:</strong> sends text to the server, like
          &#39;.dump&#39; (intended for direct server commands); output is
          queued so that the bot won&#39;t flood itself off the server.</p>

          <p><strong>Options:</strong></p>

          <blockquote>
            <p><strong>-next</strong>: push messages to the front of the
            queue<br>
            <strong>-normal</strong>: no effect</p>
          </blockquote>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> server</p>
        </dd>

        <dt><strong>puthelp &lt;text&gt; [options]</strong></dt>

        <dd>
          <p><strong>Description:</strong> sends text to the server, like
          &#39;putserv&#39;, but it uses a different queue intended for
          sending messages to channels or people.</p>

          <p><strong>Options:</strong></p>

          <blockquote>
            <p><strong>-next</strong>: push messages to the front of the
            queue<br>
            <strong>-normal</strong>: no effect</p>
          </blockquote>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> server</p>
        </dd>

        <dt><strong>putquick &lt;text&gt; [options]</strong></dt>

        <dd>
          <p><strong>Description:</strong> sends text to the server, like
          &#39;putserv&#39;, but it uses a different (and faster) queue.</p>

          <p><strong>Options:</strong></p>

          <blockquote>
            <p><strong>-next</strong>: push messages to the front of the
            queue<br>
            <strong>-normal</strong>: no effect</p>
          </blockquote>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> server</p>
        </dd>

        <dt><strong>putkick &lt;channel&gt; &lt;nick,nick,...&gt;
        [reason]</strong></dt>

        <dd>
          <p><strong>Description:</strong> sends kicks to the server and
          tries to put as many nicks into one kick command as possible.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>putlog &lt;text&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> sends text to the bot&#39;s
          logfile, marked as &#39;misc&#39; (o)</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>putcmdlog &lt;text&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> sends text to the bot&#39;s
          logfile, marked as &#39;command&#39; (c)</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>putxferlog &lt;text&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> sends text to the bot&#39;s
          logfile, marked as &#39;file-area&#39; (x)</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>putloglev &lt;level(s)&gt; &lt;channel&gt;
        &lt;text&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> sends text to the bot&#39;s
          logfile, tagged with all of the valid levels given. Use
          &quot;*&quot; to indicate all log levels.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>dumpfile &lt;nick&gt; &lt;filename&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> dumps file from the help/text
          directory to a user on IRC via msg (one line per msg). The user
          has no flags, so the flag bindings won&#39;t work within the
          file.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>queuesize [queue]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> the number of messages in all queues.
          If a queue is specified, only the size of this queue is returned.
          Valid queues are: mode, server, help.</p>

          <p><strong>Module:</strong> server</p>
        </dd>

        <dt><strong>clearqueue &lt;queue&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> removes all messages from a
          queue. Valid arguments are: mode, server, help, or all.</p>

          <p><strong>Returns:</strong> the number of deleted lines from
          the specified queue.</p>

          <p><strong>Module:</strong> server</p>
        </dd>
      </dl>
    </blockquote>

    <p><a name="urmc"></a>2. <strong>User record manipulation
    commands</strong></p>

    <blockquote>
      <dl>
        <dt><strong>countusers</strong></dt>

        <dd>
          <p><strong>Returns:</strong> number of users in the bot&#39;s
          database</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>validuser &lt;handle&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if a user by that name exists;
          0 otherwise</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>finduser &lt;nick!user@host&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> finds the user record which most
          closely matches the given nick!user@host</p>

          <p><strong>Returns:</strong> the handle found, or &quot;*&quot;
          if none</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>userlist [flags]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a list of users on the bot. You
          can use the flag matching system here
          ([global]{&amp;/|}[chan]{&amp;/|}[bot]). &#39;&amp;&#39; specifies
          &quot;and&quot;; &#39;|&#39; specifies &quot;or&quot;.</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>passwdok &lt;handle&gt; &lt;pass&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> checks the password given against
          the user&#39;s password. Check against the password &quot;&quot;
          (a blank string) or &quot;-&quot; to find out if a user has no
          password set.</p>

          <p><strong>Returns:</strong> 1 if the password matches for that
          user; 0 otherwise</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>getuser &lt;handle&gt; &lt;entry-type&gt;
        [extra info]</strong></dt>

        <dd>
          <p><strong>Description:</strong> an interface to the new generic
          userfile support. Valid entry types are:</p>

          <blockquote>
            <table>
              <tr valign="top">
                <td>
                  <p><strong>BOTFL</strong></p>
                </td>

                <td>
                  <p>returns the current bot-specific flags for the user
                  (bot-only)</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>BOTADDR</strong></p>
                </td>

                <td>
                  <p>returns a list containing the bot&#39;s address, telnet
                  port, and relay port (bot-only)</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>HOSTS</strong></p>
                </td>

                <td>
                  <p>returns a list of hosts for the user</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>LASTON</strong></p>
                </td>

                <td>
                  <p>returns a list containing the unixtime last seen and
                  the last seen place. LASTON #channel returns the time
                  last seen time for the channel or 0 if no info exists.</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>INFO</strong></p>
                </td>

                <td>
                  <p>returns the user&#39;s global info line</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>XTRA</strong></p>
                </td>

                <td>
                  <p>returns the user&#39;s XTRA info</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>COMMENT</strong></p>
                </td>

                <td>
                  <p>returns the master-visible only comment for the user</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>EMAIL</strong></p>
                </td>

                <td>
                  <p>returns the user&#39;s e-mail address</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>URL</strong></p>
                </td>

                <td>
                  <p>returns the user&#39;s url</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>HANDLE</strong></p>
                </td>

                <td>
                  <p>returns the user&#39;s handle as it is saved in the
                  userfile</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>PASS</strong></p>
                </td>

                <td>
                  <p>returns the user&#39;s encrypted password</p>
                </td>
              </tr>
            </table>
          </blockquote>

          <p><strong>Returns:</strong> info specific to each entry-type</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>setuser &lt;handle&gt; &lt;entry-type&gt;
        [extra info]</strong></dt>

        <dd>
          <p><strong>Description:</strong> this is the counterpart of
          getuser. It lets you set the various values. Other then the ones
          listed below, the entry-types are the same as getuser&#39;s.</p>

          <blockquote>
            <table>
              <tr valign="top">
                <td>
                  <p><strong>HOSTS</strong></p>
                </td>

                <td>
                  <p>if used with no third arg, all hosts for the user will
                  be cleared. Otherwise, *1* hostmask is added :P</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>LASTON</strong></p>
                </td>

                <td>
                  <p>This setting has 3 forms. &quot;setuser &lt;handle&gt;
                  LASTON &lt;unixtime&gt; &lt;place&gt;&quot; sets global
                  LASTON time, &quot;setuser &lt;handle&gt; LASTON
                  &lt;unixtime&gt;&quot; sets global LASTON time (leaving the
                  place field empty), and &quot;setuser &lt;handle&gt; LASTON
                  &lt;unixtime&gt; &lt;channel&gt;&quot; sets a users LASTON
                  time for a channel (if it is a  valid channel).</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>PASS</strong></p>
                </td>

                <td>
                  <p>sets a users password (no third arg will clear it)</p>
                </td>
              </tr>
            </table>
          </blockquote>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>chhandle &lt;old-handle&gt;
        &lt;new-handle&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> changes a user&#39;s handle</p>

          <p><strong>Returns:</strong> 1 on success; 0 if the new handle is
          invalid or already used, or if the user can&#39;t be found</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>chattr &lt;handle&gt; [changes [channel]]</strong></dt>

        <dd>
          <p><strong>Description:</strong> changes the attributes for a user
          record, if you include any. Changes are of the form &#39;+f&#39;,
          &#39;-o&#39;, &#39;+dk&#39;, &#39;-o+d&#39;, etc. If changes are
          specified in the format of &lt;changes&gt; &lt;channel&lt;, the
          channel-specific flags for that channel are altered. You can now
          use the +o|-o #channel format here too.</p>

          <p><strong>Returns:</strong>  new flags for the user (if you made
          no changes, the current flags are returned). If a channel was
          specified, the global AND the channel-specific flags for that
          channel are returned in the format of globalflags|channelflags.
          &quot;*&quot; is returned if the specified user does not exist.</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>botattr &lt;handle&gt; [changes [channel]]</strong></dt>

        <dd>
          <p><strong>Description:</strong> similar to chattr except this
          modifies bot flags rather than normal user attributes.</p>

          <p><strong>Returns:</strong>  new flags for the bot (if you made
          no changes, the current flags are returned). If a channel was
          specified, the global AND the channel-specific flags for that
          channel are returned in the format of globalflags|channelflags.
          &quot;*&quot; is returned if the specified bot does not exist.</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>matchattr &lt;handle&gt; &lt;flags&gt;
        [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the specified user has the
          specified flags; 0 otherwise</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>adduser &lt;handle&gt; [hostmask]</strong></dt>

        <dd>
          <p><strong>Description:</strong> creates a new user entry with the
          handle and hostmask given (with no password and the default
          flags)</p>

          <p><strong>Returns:</strong> 1 if successful; 0 if the handle
          already exists</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>addbot &lt;handle&gt; &lt;address&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> adds a new bot to the userlist
          with the handle and bot address given (with no password and no
          flags)</p>

          <p><strong>Returns:</strong> 1 if successful; 0 if the bot
          already exists</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>deluser &lt;handle&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> attempts to erase the user record
          for a handle</p>

          <p><strong>Returns:</strong> 1 if successful, 0 if no such user
          exists</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>delhost &lt;handle&gt; &lt;hostmask&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> deletes a hostmask from a
          user&#39;s host list</p>

          <p><strong>Returns:</strong> 1 on success; 0 if the hostmask (or
          user) doesn&#39;t exist</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>addchanrec &lt;handle&gt; &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> adds a channel record for a
          user</p>

          <p><strong>Returns:</strong> 1 on success; 0 if the user or channel
          does not exist</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>delchanrec &lt;handle&gt; &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> removes a channel record for a
          user. This includes all associated channel flags.</p>

          <p><strong>Returns:</strong> 1 on success; 0 if the user or channel
          does not exist</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>haschanrec &lt;handle&gt; &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the given handle has a chanrec
          for the specified channel; 0 otherwise</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>getchaninfo &lt;handle&gt; &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> info line for a specific channel
          (behaves just like &#39;getinfo&#39;)</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>setchaninfo &lt;handle&gt; &lt;channel&gt;
        &lt;info&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> sets the info line on a specific
          channel for a user. If info is &quot;none&quot;, it will be
          removed.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>newchanban &lt;channel&gt; &lt;ban&gt; &lt;creator&gt;
        &lt;comment&gt; [lifetime] [options]</strong></dt>

        <dd>
          <p><strong>Description:</strong> adds a ban to the ban list of a
          channel; creator is given credit for the ban in the ban list.
          lifetime is specified in minutes. If lifetime is not specified,
          ban-time (usually 60) is used. Setting the lifetime to 0 makes
          it a permanent ban.</p>

          <p><strong>Options:</strong></p>

          <blockquote>
            <p><strong>sticky</strong>: forces the ban to be always active
            on a channel, even with dynamicbans on<br>
            <strong>none</strong>: no effect</p>
          </blockquote>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>newban &lt;ban&gt; &lt;creator&gt; &lt;comment&gt;
        [lifetime] [options]</strong></dt>

        <dd>
          <p><strong>Description:</strong> adds a ban to the global ban list
          (which takes effect on all channels); creator is given credit for
          the ban in the ban list. lifetime is specified in minutes. If
          lifetime is not specified, global-ban-time (usually 60) is used.
          Setting the lifetime to 0 makes it a permanent ban.</p>

          <p><strong>Options:</strong></p>

          <blockquote>
            <p><strong>sticky</strong>: forces the ban to be always active
            on a channel, even with dynamicbans on<br>
            <strong>none</strong>: no effect</p>
          </blockquote>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>newchanexempt &lt;channel&gt; &lt;exempt&gt;
        &lt;creator&gt; &lt;comment&gt; [lifetime] [options]</strong></dt>

        <dd>
          <p><strong>Description:</strong> adds a exempt to the exempt list
          of a channel; creator is given credit for the exempt in the exempt
          list. lifetime is specified in minutes. If lifetime is not
          specified, exempt-time (usually 60) is used. Setting the lifetime
          to 0 makes it a permanent exempt. The exempt will not be removed
          until the corresponding ban has been removed. For timed bans,
          once the time period has expired, the exempt will not be removed
          until the corresponding ban has either expired or been removed.</p>

          <p><strong>Options:</strong></p>

          <blockquote>
            <p><strong>sticky</strong>: forces the exempt to be always active
            on a channel, even with dynamicexempts on<br>
            <strong>none</strong>: no effect</p>
          </blockquote>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>newexempt &lt;exempt&gt; &lt;creator&gt; &lt;comment&gt;
        [lifetime] [options]</strong></dt>

        <dd>
          <p><strong>Description:</strong> adds a exempt to the global
          exempt list (which takes effect on all channels); creator is
          given credit for the exempt in the exempt list. lifetime is
          specified in minutes. If lifetime is not specified, exempt-time
          (usually 60) is used. Setting the lifetime to 0 makes it a
          permanent exempt. The exempt will not be removed until the
          corresponding ban has been removed.</p>

          <p><strong>Options:</strong></p>

          <blockquote>
            <p><strong>sticky</strong>: forces the exempt to be always active
            on a channel, even with dynamicexempts on<br>
            <strong>none</strong>: no effect</p>
          </blockquote>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>newchaninvite &lt;channel&gt; &lt;invite&gt;
        &lt;creator&gt; &lt;comment&gt; [lifetime] [options]</strong></dt>

        <dd>
          <p><strong>Description:</strong> adds a invite to the invite list
          of a channel; creator is given credit for the invite in the invite
          list. lifetime is specified in minutes. If lifetime is not
          specified, invite-time (usually 60) is used. Setting the lifetime
          to 0 makes it a permanent invite. The invite will not be removed
          until the channel has gone -i.</p>

          <p><strong>Options:</strong></p>

          <blockquote>
            <p><strong>sticky</strong>: forces the invite to be always active
            on a channel, even with dynamicinvites on<br>
            <strong>none</strong>: no effect</p>
          </blockquote>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>newinvite &lt;invite&gt; &lt;creator&gt; &lt;comment&gt;
        [lifetime] [options]</strong></dt>

        <dd>
          <p><strong>Description:</strong> adds a invite to the global invite
          list (which takes effect on all channels); creator is given credit
          for the invite in the invite list. lifetime is specified in
          minutes. If lifetime is not specified, invite-time (usually 60)
          is used. Setting the lifetime to 0 makes it a permanent invite.
          The invite will not be removed until the channel has gone -i.</p>

          <p><strong>Options:</strong></p>

          <blockquote>
            <p><strong>sticky</strong>: forces the invite to be always active
            on a channel, even with dynamicinvites on<br>
            <strong>none</strong>: no effect</p>
          </blockquote>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>stick &lt;banmask&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Description:</strong> makes a ban sticky, or, if a
          channel is specified, then it is set sticky on that channel
          only.</p>

          <p><strong>Returns:</strong> 1 on success; 0 otherwise</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>unstick &lt;banmask&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Description:</strong> makes a ban no longer sticky,
          or, if a channel is specified, then it is unstuck on that channel
          only.</p>

          <p><strong>Returns:</strong> 1 on success; 0 otherwise</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>stickexempt &lt;exemptmask&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Description:</strong> makes an exempt sticky, or, if
          a channel is specified, then it is set sticky on that channel
          only.</p>

          <p><strong>Returns:</strong> 1 on success; 0 otherwise</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>unstickexempt &lt;exemptmask&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Description:</strong> makes an exempt no longer sticky,
          or, if a channel is specified, then it is unstuck on that channel
          only.</p>

          <p><strong>Returns:</strong> 1 on success; 0 otherwise</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>stickinvite &lt;invitemask&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Description:</strong> makes an invite sticky, or, if
          a channel is specified, then it is set sticky on that channel
          only.</p>

          <p><strong>Returns:</strong> 1 on success; 0 otherwise</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>unstickinvite &lt;invitemask&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Description:</strong> makes an invite no longer sticky,
          or, if a channel is specified, then it is unstuck on that channel
          only.</p>

          <p><strong>Returns:</strong> 1 on success; 0 otherwise</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>killchanban &lt;channel&gt; &lt;ban&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> removes a ban from the ban list
          for a channel</p>

          <p><strong>Returns:</strong> 1 on success; 0 otherwise</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>killban &lt;ban&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> removes a ban from the global
          ban list</p>

          <p><strong>Returns:</strong> 1 on success; 0 otherwise</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>killchanexempt &lt;channel&gt;
        &lt;exempt&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> removes an exempt from the exempt
          list for a channel</p>

          <p><strong>Returns:</strong> 1 on success; 0 otherwise</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>killexempt &lt;exempt&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> removes an exempt from the global
          exempt list</p>

          <p><strong>Returns:</strong> 1 on success; 0 otherwise</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>killchaninvite &lt;channel&gt; &lt;invite&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> removes an invite from the invite
          list for a channel</p>

          <p><strong>Returns:</strong> 1 on success; 0 otherwise</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>killinvite &lt;invite&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> removes an invite from the global
          invite list</p>

          <p><strong>Returns:</strong> 1 on success; 0 otherwise</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>ischanjuped &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the channel is juped, and the
          bot is unable to join; 0 otherwise</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>isban &lt;ban&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the specified ban is in the
          global ban list; 0 otherwise. If a channel is specified, that
          channel&#39;s ban list is checked as well.</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>ispermban &lt;ban&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the specified ban is in the
          global ban list AND is marked as permanent; 0 otherwise. If a
          channel is specified, that channel&#39;s ban list is checked as
          well.</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>isexempt &lt;exempt&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the specified exempt is in the
          global exempt list; 0 otherwise. If a channel is specified, that
          channel&#39;s exempt list is checked as well.</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>ispermexempt &lt;exempt&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the specified exempt is in the
          global exempt list AND is marked as permanent; 0 otherwise. If a
          channel is specified, that channel&#39;s exempt list is checked
          as well.</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>isinvite &lt;invite&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the specified invite is in
          the global invite list; 0 otherwise. If a channel is specified,
          that channel&#39;s invite list is checked as well.</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>isperminvite &lt;invite&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the specified invite is in
          the global invite list AND is marked as permanent; 0 otherwise.
          If a channel is specified, that channel&#39;s invite list is
          checked as well.</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>isbansticky &lt;ban&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the specified ban is marked as
          sticky in the global ban list; 0 otherwise. If a channel is
          specified, that channel&#39;s ban list is checked as well.</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>isexemptsticky &lt;exempt&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the specified exempt is marked
          as sticky in the global exempt list; 0 otherwise. If a channel is
          specified, that channel&#39;s exempt list is checked as well.</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>isinvitesticky &lt;invite&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the specified invite is marked
          as sticky in the global invite list; 0 otherwise. If a channel
          is specified, that channel&#39;s invite list is checked as well.</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>matchban &lt;nick!user@host&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the specified nick!user@host
          matches a ban in the global ban list; 0 otherwise. If a channel
          is specified, that channel&#39;s ban list is checked as well.</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>matchexempt &lt;nick!user@host&gt;
        [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the specified nick!user@host
          matches an exempt in the global exempt list; 0 otherwise. If a
          channel is specified, that channel&#39;s exempt list is checked
          as well.</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>matchinvite &lt;nick!user@host&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the specified nick!user@host
          matches an invite in the global invite list; 0 otherwise. If a
          channel is specified, that channel&#39;s invite list is checked
          as well.</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>banlist [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a list of global bans, or, if a
          channel is specified, a list of channel-specific bans. Each entry
          is a sublist containing: hostmask, comment, expiration timestamp,
          time added, last time active, and creator. The three timestamps
          are in unixtime format.</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>exemptlist [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a list of global exempts, or, if a
          channel is specified, a list of channel-specific exempts. Each
          entry is a sublist containing: hostmask, comment, expiration
          timestamp, time added, last time active, and creator. The three
          timestamps are in unixtime format.</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>invitelist [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a list of global invites, or, if a
          channel is specified, a list of channel-specific invites. Each
          entry is a sublist containing: hostmask, comment, expiration
          timestamp, time added, last time active, and creator. The three
          timestamps are in unixtime format.</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>newignore &lt;hostmask&gt; &lt;creator&gt;
        &lt;comment&gt; [lifetime]</strong></dt>

        <dd>
          <p><strong>Description:</strong> adds an entry to the ignore list;
          creator is given credit for the ignore. lifetime is how many
          minutes until the ignore expires and is removed. If lifetime is
          not specified, ignore-time (usually 60) is used. Setting the
          lifetime to 0 makes it a permanent ignore.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>killignore &lt;hostmask&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> removes an entry from the ignore
          list</p>

          <p><strong>Returns:</strong> 1 if successful; 0 otherwise</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>ignorelist</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a list of ignores. Each entry is a
          sublist containing: hostmask, comment, expiration timestamp, time
          added, and creator. The timestamps are in unixtime format.</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>isignore &lt;hostmask&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the ignore is in the list;
          0 otherwise</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>save</strong></dt>

        <dd>
          <p><strong>Description:</strong> writes the user and channel files
          to disk</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>reload</strong></dt>

        <dd>
          <p><strong>Description:</strong> loads the userfile from disk,
          replacing whatever is in memory</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>backup</strong></dt>

        <dd>
          <p><strong>Description:</strong> makes a simple backup of the
          userfile that&#39;s on disk. If the channels module is loaded,
          this also makes a simple backup of the channel file.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>getting-users</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the bot is currently downloading
          a userfile from a sharebot (and hence, user records are about to
          drastically change); 0 if not</p>

          <p><strong>Module:</strong> core</p>
        </dd>
      </dl>
    </blockquote>

    <p><a name="chancmds"></a>3. <strong>Channel commands</strong></p>

    <blockquote>
      <dl>
        <dt><strong>channel add &lt;name&gt; [option-list]</strong></dt>

        <dd>
          <p><strong>Description:</strong> adds a channel record for the
          bot to monitor. The full list of possible options are given in
          doc/settings/mod.channels. Note that the channel options must be
          in a list (enclosed in {}).</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>channel set &lt;name&gt; &lt;options...&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> sets options for the channel
          specified. The full list of possible options are given in
          doc/settings/mod.channels.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>channel info &lt;name&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a list of info about the specified
          channel&#39;s settings.</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>channel get &lt;name&gt; &lt;setting&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> The value of the setting you specify.
          For flags, a value of 0 means it is disabled (-), and non-zero means
          enabled (+).</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>channel remove &lt;name&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> removes a channel record from
          the bot and makes the bot no longer monitor the channel</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>savechannels</strong></dt>

        <dd>
          <p><strong>Description:</strong> saves the channel settings to
          the channel-file if one is defined.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>loadchannels</strong></dt>

        <dd>
          <p><strong>Description:</strong> reloads the channel settings from
          the channel-file if one is defined.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>channels</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a list of the channels the bot has
          a channel record for</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>channame2dname &lt;channel-name&gt;</strong></dt>
        <dt><strong>chandname2name &lt;channel-dname&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> these two functions are important
          to correctly support !channels. The bot differentiates between
          channel description names (chan dnames) and real channel names
          (chan names). The chan dnames are what you would normally call
          the channel, such as &quot;!channel&quot;. The chan names are
          what the IRC server uses to identify the channel. They consist
          of the chan dname prefixed with an ID; such as
          &quot;!ABCDEchannel&quot;.</p>

          <p>For bot functions like isop, isvoice, etc. you need to know
          the chan dnames. If you communicate with the server, you usually
          get the chan name, though. That&#39;s what you need the
          channame2dname function for.</p>

          <p>If you only have the chan dname and want to directly send raw
          server commands, use the chandname2name command.</p>

          <p>For non-!channels, chan dname and chan name are the same.</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>isbotnick &lt;nick&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the nick matches the botnick;
          0 otherwise</p>

          <p><strong>Module:</strong> server</p>
        </dd>

        <dt><strong>botisop [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the bot has ops on the specified
          channel (or any channel if no channel is specified); 0
          otherwise</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>botishalfop [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the bot has halfops on the
          specified channel (or any channel if no channel is specified); 0
          otherwise</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>botisvoice [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the bot has a voice on the
          specified channel (or any channel if no channel is specified); 0
          otherwise</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>botonchan [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the bot is on the specified
          channel (or any channel if no channel is specified); 0
          otherwise</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>isop &lt;nickname&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if someone by the specified
          nickname is on the channel (or any channel if no channel name is
          specified) and has ops; 0 otherwise</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>ishalfop &lt;nickname&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if someone by the specified
          nickname is on the channel (or any channel if no channel name is
          specified) and has halfops; 0 otherwise</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>wasop &lt;nickname&gt; &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if someone that just got
          opped/deopped in the chan had op before the modechange; 0
          otherwise</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>washalfop &lt;nickname&gt; &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if someone that just got
          halfopped/dehalopped in the chan had halfop before the modechange; 0
          otherwise</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>isvoice &lt;nickname&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if someone by that nickname is on
          the channel (or any channel if no channel is specified) and has
          voice (+v); 0 otherwise</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>onchan &lt;nickname&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if someone by that nickname is on
          the specified channel (or any channel if none is specified); 0
          otherwise</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>nick2hand &lt;nickname&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> the handle of a nickname on a channel.
          If a channel is not specified, the bot will check all of its
          channels. If the nick is not found, &quot;&quot; is returned. If
          the nick is found but does not have a handle, &quot;*&quot; is
          returned.</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>hand2nick &lt;handle&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> nickname of the first person on the
          specified channel (if one is specified) whose nick!user@host
          matches the given handle; &quot;&quot; is returned if no match
          is found. If no channel is specified, all channels are checked.</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>handonchan &lt;handle&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the the nick!user@host for
          someone on the channel (or any channel if no channel name is
          specified) matches for the handle given; 0 otherwise</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>ischanban &lt;ban&gt; &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the specified ban is on the
          given channel&#39;s ban list (not the bot&#39;s banlist for the
          channel)</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>ischanexempt &lt;exempt&gt; &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the specified exempt is on the
          given channel&#39;s exempt list (not the bot&#39;s exemptlist for
          the channel)</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>ischaninvite &lt;invite&gt; &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the specified invite is on the
          given channel&#39;s invite list (not the bot&#39;s invitelist for
          the channel)</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>chanbans &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a list of the current bans on the
          channel. Each element is a sublist of the form {&lt;ban&gt;
          &lt;bywho&gt; &lt;age&gt;}. age is seconds from the bot&#39;s
          point of view</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>chanexempts &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a list of the current exempts on the
          channel. Each element is a sublist of the form {&lt;exempts&gt;
          &lt;bywho&gt; &lt;age&gt;}. age is seconds from the bot&#39;s
          point of view</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>chaninvites &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a list of the current invites on the
          channel. Each element is a sublist of the form {&lt;invites&gt;
          &lt;bywho&gt; &lt;age&gt;}. age is seconds from the bot&#39;s
          point of view</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>resetbans &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> removes all bans on the channel
          that aren&#39;t in the bot&#39;s ban list and refreshes any bans
          that should be on the channel but aren&#39;t</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>resetexempts [channel]</strong></dt>

        <dd>
          <p><strong>Description:</strong> removes all exempt on the channel
          that aren&#39;t in the bot&#39;s exempt list and refreshes any
          exempts that should be on the channel but aren&#39;t</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>resetinvites [channel]</strong></dt>

        <dd>
          <p><strong>Description:</strong> removes all invites on the channel
          that aren&#39;t in the bot&#39;s invite list and refreshes any
          invites that should be on the channel but aren&#39;t</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>resetchan &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> </p>

          <p><strong>Returns:</strong> rereads in the channel info from the
          server</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>getchanhost &lt;nickname&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> user@host of the specified nickname
          (the nickname is not included in the returned host). If a channel
          is not specified, bot will check all of its channels. If the
          nickname is not on the channel(s), &quot;&quot; is returned.</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>getchanjoin &lt;nickname&gt; &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> timestamp (unixtime format) of when
          the specified nickname joined the channel</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>onchansplit &lt;nick&gt; [channel]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if that nick is split from the
          channel (or any channel if no channel is specified); 0
          otherwise</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>chanlist &lt;channel&gt;
        [flags[&amp;chanflags]]</strong></dt>

        <dd>
          <p><strong>Description:</strong> flags are any global flags; the
          &#39;&amp;&#39; denotes to look for channel specific flags.
          Examples:</p>

          <blockquote>
            <table>
              <tr valign="top">
                <td>
                  <p><strong>n</strong></p>
                </td>

                <td>
                  <p>Global Owner</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>&amp;n</strong></p>
                </td>

                <td>
                  <p>Channel Owner</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>o&amp;m</strong></p>
                </td>

                <td>
                  <p>Global Op, Channel Master</p>
                </td>
              </tr>
            </table>
          </blockquote>

          <p><strong>Returns:</strong> list of nicknames currently on the
          bot&#39;s channel that have all of the flags specified;. If no
          flags are given, all of the nicknames are returned. Please note
          that if you&#39;re executing chanlist after a part or sign bind,
          the gone user will still be listed, so you can check for wasop,
          isop, etc.</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>getchanidle &lt;nickname&gt; &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> number of minutes that person has
          been idle; 0 if the specified user isn&#39;t on the channel</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>getchanmode &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> string of the type &quot;+ntik
          key&quot; for the channel specified</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>jump [server [port [password]]]</strong></dt>

        <dd>
          <p><strong>Description:</strong> jumps to the server specified,
          or (if none is specified) the next server in the bot&#39;s
          serverlist</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> server</p>
        </dd>

        <dt><strong>pushmode &lt;channel&gt; &lt;mode&gt; [arg]</strong></dt>

        <dd>
          <p><strong>Description:</strong> sends out a channel mode change
          (ex: pushmode #lame +o goober) through the bot&#39;s queuing
          system. All the mode changes will be sent out at once (combined
          into one line as much as possible) after the script finishes, or
          when &#39;flushmode&#39; is called.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>flushmode &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> forces all previously pushed
          channel mode changes to be sent to the server, instead of when
          the script is finished (just for the channel specified)</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>topic &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> string containing the current topic
          of the specified channel</p>

          <p><strong>Module:</strong> irc</p>
        </dd>

        <dt><strong>validchan &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> checks if the bot has a channel
          record for the specified channel. Note that this does not
          necessarily mean that the bot is ON the channel.</p>

          <p><strong>Returns:</strong> 1 if the channel exists, 0 if not</p>

          <p><strong>Module:</strong> nothing</p>
        </dd>

        <dt><strong>isdynamic &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the channel is a dynamic
          channel; 0 otherwise</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>setudef &lt;flag/int/str&gt; &lt;name&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> initializes a user defined channel
          flag, string, or integer setting. You can use it like any other
          flag/setting. IMPORTANT: Don&#39;t forget to reinitialize your
          flags/settings after a restart, or it&#39;ll be lost.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>renudef &lt;flag/int/str&gt; &lt;oldname&gt;
        &lt;newname&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> renames a user defined channel
          flag, string, or integer setting.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> channels</p>
        </dd>

        <dt><strong>deludef &lt;flag/int/str&gt; &lt;name&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> deletes a user defined channel
          flag, string, or integer setting.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> channels</p>
        </dd>
      </dl>
    </blockquote>

    <p><a name="dcccmds"></a>4. <strong>Dcc commands</strong></p>

    <blockquote>
      <dl>
        <dt><strong>putdcc &lt;idx&gt; &lt;text&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> sends text to the idx specified</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>dccbroadcast &lt;message&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> sends a message to everyone on
          the party line across the botnet, in the form of &quot;***
          &lt;message&gt;&quot; for local users and &quot;*** (Bot)
          &lt;message&gt;&quot; for users on other bots</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>dccputchan &lt;channel&gt; &lt;message&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> sends your message to everyone
          on a certain channel on the botnet, in a form exactly like
          dccbroadcast does. Valid channels are 0 through 99999.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>boot &lt;user@bot&gt; [reason]</strong></dt>

        <dd>
          <p><strong>Description:</strong> boots a user from the partyline</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>dccsimul &lt;idx&gt; &lt;text&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> simulates text typed in by the
          dcc user specified. Note that in v0.9, this only simulated
          commands; now a command must be preceded by a &#39;.&#39; to be
          simulated.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>hand2idx &lt;handle&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> the idx (a number greater than or
          equal to zero) for the user given if the user is on the party
          line in chat mode (even if she is currently on a channel or in
          chat off), the file area, or in the control of a script. -1 is
          returned if no idx is found. If the user is on multiple times,
          the oldest idx is returned.</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>idx2hand &lt;idx&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> handle of the user with the given
          idx</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>valididx &lt;idx&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the idx currently exists; 0
          otherwise</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>getchan &lt;idx&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> the current party line channel
          for a user on the party line; &quot;0&quot; indicates he&#39;s
          on the group party line, &quot;-1&quot; means he has chat off,
          and a value from 1 to 99999 is a private channel</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>setchan &lt;idx&gt; &lt;channel&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> sets a party line user&#39;s
          channel. The party line user is not notified that she is now on
          a new channel. A channel name can be used (provided it exists).</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>console &lt;idx&gt; [channel]
        [console-modes]</strong></dt>

        <dd>
          <p><strong>Description:</strong> changes a dcc user&#39;s console
          mode, either to an absolute mode (like &quot;mpj&quot;) or just
          adding/removing flags (like &quot;+pj&quot; or &quot;-moc&quot;
          or &quot;+mp-c&quot;). The user&#39;s console channel view can be
          changed also (as long as the new channel is a valid channel).</p>

          <p><strong>Returns:</strong> a list containing the user&#39;s (new)
          channel view and (new) console modes, or nothing if that user
          isn&#39;t currently on the partyline</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>echo &lt;idx&gt; [status]</strong></dt>

        <dd>
          <p><strong>Description:</strong> turns a user&#39;s echo on or
          off; the status has to be a 1 or 0</p>

          <p><strong>Returns:</strong> new value of echo for that user (or
          the current value, if status was omitted)</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>strip &lt;idx&gt; [+/-strip-flags]</strong></dt>

        <dd>
          <p><strong>Description:</strong> modifies the strip-flags for a
          user. The supported strip-flags are:</p>

          <blockquote>
            <table>
              <tr valign="top">
                <td>
                  <p><strong>b</strong></p>
                </td>

                <td>
                  <p>remove all boldface codes</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>c</strong></p>
                </td>

                <td>
                  <p>remove all color codes</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>r</strong></p>
                </td>

                <td>
                  <p>remove all reverse video codes</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>u</strong></p>
                </td>

                <td>
                  <p>remove all underline codes</p>
                </td>
              </tr>


              <tr valign="top">
                <td>
                  <p><strong>a</strong></p>
                </td>

                <td>
                  <p>remove all ANSI codes</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>g</strong></p>
                </td>

                <td>
                  <p>remove all ctrl-g (bell) codes</p>
                </td>
              </tr>
            </table>
          </blockquote>

          <p><strong>Returns:</strong> new strip-flags for the specified user
          (or the current flags, if strip-flags was omitted)</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>putbot &lt;bot-nick&gt; &lt;message&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> sends a message across the
          botnet to another bot. If no script intercepts the message on
          the other end, the message is ignored.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>putallbots &lt;message&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> sends a message across the botnet
          to all bots. If no script intercepts the message on the other end,
          the message is ignored.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>killdcc &lt;idx&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> kills a partyline or file area
          connection</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>bots</strong></dt>

        <dd>
          <p><strong>Returns:</strong> list of the bots currently connected
          to the botnet</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>botlist</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a list of bots currently on the
          botnet. Each item in the list is a sublist with four elements:
          bot, uplink, version, sharing status:</p>

          <blockquote>
            <table>
              <tr valign="top">
                <td>
                  <p><strong>bot</strong></p>
                </td>

                <td>
                  <p>the bot&#39;s botnetnick</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>uplink</strong></p>
                </td>

                <td>
                  <p>the bot the bot is connected to</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>version</strong></p>
                </td>

                <td>
                  <p>its current numeric version</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>sharing</strong></p>
                </td>

                <td>
                  <p>a &quot;+&quot; if the bot is a sharebot; &quot;-&quot;
                  otherwise</p>
                </td>
              </tr>
            </table>
          </blockquote>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>killdcc &lt;idx&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> kills a partyline or file area
          connection</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>islinked &lt;bot&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> 1 if the bot is currently linked; 0
          otherwise</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>dccused</strong></dt>

        <dd>
          <p><strong>Returns:</strong> number of dcc connections currently
          in use</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>dcclist [type]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a list of active connections, each
          item in the list is a sublist containing six elements: {&lt;idx&gt;
          &lt;handle&gt; &lt;hostname&gt; &lt;type&gt; {&lt;other&gt;}
          &lt;timestamp&gt;}</p>

          <p>The types are: chat, bot, files, file_receiving, file_sending,
          file_send_pending, script, socket (these are connections that
          have not yet been put under &#39;control&#39;), telnet, and server.
          The timestamp is in unixtime format.</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>whom &lt;chan&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> list of people on the botnet who are
          on that channel. 0 is the default party line. Each item in the
          list is a sublist with six elements: nickname, bot, hostname,
          access flag (&#39;-&#39;, &#39;@&#39;, &#39;+&#39;, or
          &#39;*&#39;), minutes idle, and away message (blank if the user
          is not away). If you specify * for channel, every user on the
          botnet is returned with an extra argument indicating the channel
          the user is on.</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>getdccidle &lt;idx&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> number of seconds the dcc chat/file
          system/script user has been idle</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>getdccaway &lt;idx&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> away message for a dcc chat user
          (or &quot;&quot; if the user is not set away)</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>setdccaway &lt;idx&gt; &lt;message&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> sets a party line user&#39;s away
          message and marks them away. If set to &quot;&quot;, the user is
          marked as no longer away.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>connect &lt;host&gt; &lt;port&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> makes an outgoing connection
          attempt and creates a dcc entry for it. A &#39;control&#39;
          command should be used immediately after a successful
          &#39;connect&#39; so no input is lost.</p>

          <p><strong>Returns:</strong> idx of the new connection</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>listen &lt;port&gt; &lt;type&gt; [options]
        [flag]</strong></dt>

        <dd>
          <p><strong>Description:</strong> opens a listening port to accept
          incoming telnets; type must be one of &quot;bots&quot;,
          &quot;all&quot;, &quot;users&quot;, &quot;script&quot;, or
          &quot;off&quot;:</p>

          <blockquote>
            <dl>
              <dt><strong>listen &lt;port&gt; bots [mask]</strong></dt>

              <dd>
                <p><strong>Description:</strong> accepts connections from
                bots only; the optional mask is used to identify permitted
                bot names. If the mask begins with &#39;@&#39;, it is
                interpreted to be a mask of permitted hosts to accept
                connections from.</p>

                <p><strong>Returns:</strong> port number</p>
              </dd>

              <dt><strong>listen &lt;port&gt; users [mask]</strong></dt>

              <dd>
                <p><strong>Description:</strong> accepts connections from
                users only (no bots); the optional mask is used to identify
                permitted nicknames. If the mask begins with &#39;@&#39;, it
                is interpreted to be a mask of permitted hosts to accept
                connections from.</p>

                <p><strong>Returns:</strong> port number</p>
              </dd>

              <dt><strong>listen &lt;port&gt; all [mask]</strong></dt>

              <dd>
                <p><strong>Description:</strong> accepts connections from
                anyone; the optional mask is used to identify permitted
                nicknames/botnames. If the mask begins with &#39;@&#39;,
                it is interpreted to be a mask of permitted hosts to accept
                connections from.</p>

                <p><strong>Returns:</strong> port number</p>
              </dd>

              <dt><strong>listen &lt;port&gt; script &lt;proc&gt;
              [flag]</strong></dt>

              <dd>
                <p><strong>Description:</strong> accepts connections which
                are immediately routed to a proc. The proc is called with
                one parameter: the idx of the new connection. Flag may
                currently only be &#39;pub&#39;, which makes the bot allow
                anyone to connect.</p>

                <p><strong>Returns:</strong> port number</p>
              </dd>

              <dt><strong>listen &lt;port&gt; off</strong></dt>

              <dd>
                <p><strong>Description:</strong> stop listening on a port</p>

                <p><strong>Returns:</strong> nothing</p>
              </dd>
            </dl>
          </blockquote>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>dccdumpfile &lt;idx&gt; &lt;filename&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> dumps out a file from the text
          directory to a dcc chat user. The flag matching that&#39;s used
          everywhere else works here, too.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>
      </dl>
    </blockquote>

    <p><a name="notes"></a>5. <strong>Notes module</strong></p>

    <blockquote>
      <dl>
        <dt><strong>notes &lt;user&gt; [numberlist]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> -1 if no such user, -2 if notefile
          failure. If a numberlist is not specified, the number of notes
          stored for the user is returned. Otherwise, a list of sublists
          containing information about notes stored for the user is
          returned. Each sublist is in the format of: {&lt;from&gt;
          &lt;timestamp&gt; &lt;note text&gt;}.</p>

          <p><strong>Module:</strong> notes</p>
        </dd>

        <dt><strong>erasenotes &lt;user&gt; &lt;numberlist&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> erases some or all stored notes
          for a user. Use &#39;-&#39; to erase all notes.</p>

          <p><strong>Returns:</strong> -1 if no such user, -2 if notefile
          failure, 0 if no such note, or number of erased notes.</p>

          <p><strong>Module:</strong> notes</p>
        </dd>

        <dt><strong>listnotes &lt;user&gt; &lt;numberlist&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> lists existing notes according
          to the numberlist (ex: &quot;2-4;8;16-&quot;)</p>

          <p><strong>Returns:</strong> -1 if no such user, -2 if notefile
          failure, 0 if no such note, list of existing notes.</p>

          <p><strong>Module:</strong> notes</p>
        </dd>

        <dt><strong>storenote &lt;from&gt; &lt;to&gt; &lt;msg&gt;
        &lt;idx&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> stores a note for later reading,
          notifies idx of any results (use idx -1 for no notify).</p>

          <p><strong>Returns:</strong> 0 on success; non-0 on failure</p>

          <p><strong>Module:</strong> notes</p>
        </dd>
      </dl>
    </blockquote>

    <p><a name="assoc"></a>6. <strong>Assoc module</strong></p>

    <blockquote>
      <dl>
        <dt><strong>assoc &lt;chan&gt; [name]</strong></dt>

        <dd>
          <p><strong>Description:</strong> sets the name associated with a
          botnet channel, if you specify one</p>

          <p><strong>Returns:</strong> current name for that channel, if
          any</p>

          <p><strong>Module:</strong> assoc</p>
        </dd>

        <dt><strong>killassoc &lt;chan&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> removes the name associated
          with a botnet channel, if any exists. Use &#39;killassoc &amp;&#39;
          to kill all assocs.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> assoc</p>
        </dd>
      </dl>
    </blockquote>

    <p><a name="compress"></a>7. <strong>Compress module</strong></p>

    <blockquote>
      <dl>
        <dt><strong>compressfile [-level &lt;level&gt;] &lt;src-file&gt;
        [target-file]<br>
        uncompressfile &lt;src-file&gt; [target-file]</strong></dt>

        <dd>
          <p><strong>Description:</strong> compresses or un-compresses
          files. The level option specifies the compression mode to use
          when compressing. Available modes are from 0 (minimum CPU usage,
          minimum compression) all the way up to 9 (maximum CPU usage,
          maximum compression). If you don&#39;t specify the target-file,
          the src-file will be overwritten.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> compress</p>
        </dd>

        <dt><strong>iscompressed &lt;filename&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> determines whether
          &lt;filename&gt; is gzip compressed. Returns 1 if it is, 0 if it
          isn&#39;t, and 2 if some kind of error prevented the checks from
          succeeding.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> compress</p>
        </dd>
      </dl>
    </blockquote>

    <p><a name="filesys"></a>8. <strong>Filesys module</strong></p>

    <blockquote>
      <dl>
        <dt><strong>setpwd &lt;idx&gt; &lt;dir&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> changes the directory of a file
          system user, in exactly the same way as a &#39;cd&#39; command
          would. The directory can be specified relative or absolute.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> filesys</p>
        </dd>

        <dt><strong>getpwd &lt;idx&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> the current directory of a file
          system user</p>

          <p><strong>Module:</strong> filesys</p>
        </dd>

        <dt><strong>getfiles &lt;dir&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a list of files in the directory
          given; the directory is relative to dcc-path</p>

          <p><strong>Module:</strong> filesys</p>
        </dd>

        <dt><strong>getdirs &lt;dir&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a list of subdirectories in the
          directory given; the directory is relative to dcc-path</p>

          <p><strong>Module:</strong> filesys</p>
        </dd>

        <dt><strong>dccsend &lt;filename&gt; &lt;ircnick&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> attempts to start a dcc file
          transfer to the given nick; the filename must be specified either
          by full pathname or in relation to the bot&#39;s startup
          directory</p>

          <p><strong>Returns:</strong></p>

          <blockquote>
            <table>
              <tr valign="top">
                <td>
                  <p><strong>0</strong></p>
                </td>

                <td>
                  <p>success</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>1</strong></p>
                </td>

                <td>
                  <p>the dcc table is full (too many connections)</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>2</strong></p>
                </td>

                <td>
                  <p>can&#39;t open a socket for the transfer</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>3</strong></p>
                </td>

                <td>
                  <p>the file doesn&#39;t exist</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>4</strong></p>
                </td>

                <td>
                  <p>the file was queued for later transfer, which means that
                  person has too many file transfers going right now</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>5</strong></p>
                </td>

                <td>
                  <p>copy-to-tmp is enabled and the file already exists in the
                  temp directory</p>
                </td>
              </tr>
            </table>
          </blockquote>

          <p><strong>Module:</strong> transfer</p>
        </dd>

        <dt><strong>filesend &lt;idx&gt; &lt;filename&gt;
        [ircnick]</strong></dt>

        <dd>
          <p><strong>Description:</strong> like dccsend, except it operates
          for a current filesystem user, and the filename is assumed to be
          a relative path from that user&#39;s current directory</p>

          <p><strong>Returns:</strong> 0 on failure; 1 on success (either an
          immediate send or a queued send)</p>

          <p><strong>Module:</strong> filesys</p>
        </dd>

        <dt><strong>fileresend &lt;idx&gt; &lt;filename&gt;
        [ircnick]</strong></dt>

        <dd>
          <p><strong>Description:</strong> functions like filesend, only that
          it sends a DCC RESEND instead of a DCC SEND, which allows people
          to resume aborted file transfers if their client supports that
          protocol. ircII/BitchX/etc. support it; mIRC does not.</p>

          <p><strong>Returns:</strong> 0 on failure; 1 on success (either
          an immediate send or a queued send)</p>

          <p><strong>Module:</strong> filesys</p>
        </dd>

        <dt><strong>setdesc &lt;dir&gt; &lt;file&gt; &lt;desc&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> sets the description for a file
          in a file system directory; the directory is relative to
          dcc-path</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> filesys</p>
        </dd>

        <dt><strong>getdesc &lt;dir&gt; &lt;file&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> the description for a file in the
          file system, if one exists</p>

          <p><strong>Module:</strong> filesys</p>
        </dd>

        <dt><strong>setowner &lt;dir&gt; &lt;file&gt;
        &lt;handle&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> changes the owner for a file in
          the file system; the directory is relative to dcc-path</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> filesys</p>
        </dd>

        <dt><strong>getowner &lt;dir&gt; &lt;file&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> the owner of a file in the file
          system</p>

          <p><strong>Module:</strong> filesys</p>
        </dd>

        <dt><strong>setlink &lt;dir&gt; &lt;file&gt; &lt;link&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> creates or changes a linked file
          (a file that actually exists on another bot); the directory is
          relative to dcc-path</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> filesys</p>
        </dd>

        <dt><strong>getlink &lt;dir&gt; &lt;file&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> the link for a linked file, if it
          exists</p>

          <p><strong>Module:</strong> filesys</p>
        </dd>

        <dt><strong>getfileq &lt;handle&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> list of files queued by someone;
          each item in the list will be a sublist with two elements: nickname
          the file is being sent to and the filename</p>

          <p><strong>Module:</strong> transfer</p>
        </dd>

        <dt><strong>getfilesendtime &lt;idx&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> the unixtime value for when a file
          transfer started, or a negative number:</p>

          <blockquote>
            <table>
              <tr valign="top">
                <td>
                  <p><strong>-1</strong></p>
                </td>

                <td>
                  <p>no matching transfer with the specified idx was found</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>-2</strong></p>
                </td>

                <td>
                  <p>the idx matches an entry which is not a file transfer</p>
                </td>
              </tr>
            </table>
          </blockquote>

          <p><strong>Module:</strong> transfer</p>
        </dd>

        <dt><strong>mkdir &lt;directory&gt; [&lt;required-flags&gt;
        [channel]]</strong></dt>

        <dd>
          <p><strong>Description:</strong> creates a directory in the file
          system. Only users with the required flags may access it.</p>

          <p><strong>Returns:</strong></p>

          <blockquote>
            <table>
              <tr valign="top">
                <td>
                  <p><strong>0</strong></p>
                </td>

                <td>
                  <p>success</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>1</strong></p>
                </td>

                <td>
                  <p>can&#39;t create directory</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>2</strong></p>
                </td>

                <td>
                  <p>directory exists but is not a directory</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>-3</strong></p>
                </td>

                <td>
                  <p>could not open filedb</p>
                </td>
              </tr>
            </table>
          </blockquote>

          <p><strong>Module:</strong> filesys</p>
        </dd>

        <dt><strong>rmdir &lt;directory&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> removes a directory from the
          file system.</p>

          <p><strong>Returns:</strong> 0 on success; 1 on failure</p>

          <p><strong>Module:</strong> filesys</p>
        </dd>

        <dt><strong>mv &lt;file&gt; &lt;destination&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> moves a file from its source to
          the given destination. The file can also be a mask, such as
          /incoming/*, provided the destination is a directory.</p>

          <p><strong>Returns:</strong> If the command was successful, the
          number of files moved will be returned. Otherwise, a negative
          number will be returned:</p>

          <blockquote>
            <table>
              <tr valign="top">
                <td>
                  <p><strong>-1</strong></p>
                </td>

                <td>
                  <p>invalid source file</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>-2</strong></p>
                </td>

                <td>
                  <p>invalid destination</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>-3</strong></p>
                </td>

                <td>
                  <p>destination file exists</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>-4</strong></p>
                </td>

                <td>
                  <p>no matches found</p>
                </td>
              </tr>
            </table>
          </blockquote>

          <p><strong>Module:</strong> filesys</p>
        </dd>

        <dt><strong>cp &lt;file&gt; &lt;destination&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> copies a file from its source
          to the given destination. The file can also be a mask, such as
          /incoming/*, provided the destination is a directory.</p>

          <p><strong>Returns:</strong> If the command was successful, the
          number of files copied will be returned. Otherwise, a negative
          number will be returned:</p>

          <blockquote>
            <table>
              <tr valign="top">
                <td>
                  <p><strong>-1</strong></p>
                </td>

                <td>
                  <p>invalid source file</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>-2</strong></p>
                </td>

                <td>
                  <p>invalid destination</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>-3</strong></p>
                </td>

                <td>
                  <p>destination file exists</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>-4</strong></p>
                </td>

                <td>
                  <p>no matches found</p>
                </td>
              </tr>
            </table>
          </blockquote>

          <p><strong>Module:</strong> filesys</p>
        </dd>

        <dt><strong>getflags &lt;dir&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> the flags required to access a
          directory</p>

          <p><strong>Module:</strong> filesys</p>
        </dd>

        <dt><strong>setflags &lt;dir&gt; [&lt;flags&gt;
        [channel]]</strong></dt>

        <dd>
          <p><strong>Description:</strong> sets the flags required to
          access a directory</p>

          <p><strong>Returns:</strong> 0 on success; -1 or -3 on failure</p>

          <p><strong>Module:</strong> filesys</p>
        </dd>
      </dl>
    </blockquote>

    <p><a name="misc"></a>9. <strong>Miscellaneous commands</strong></p>

    <blockquote>
      <dl>
        <dt><strong>bind &lt;type&gt; &lt;flags&gt; &lt;keyword/mask&gt;
        [proc-name]</strong></dt>

        <dd>
          <p><strong>Description:</strong> You can use the &#39;bind&#39;
          command to attach Tcl procedures to certain events. flags are the
          flags the user must have to trigger the event (if applicable).
          proc-name is the name of the Tcl procedure to call for this
          command (see below for the format of the procedure call). If the
          proc-name is omitted, no binding is added. Instead, the current
          binding is returned (if it&#39;s stackable, a list of the current
          bindings is returned).</p>

          <p><strong>Returns:</strong> name of the command that was added,
          or (if proc-name was omitted), a list of the current bindings for
          this command</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>unbind &lt;type&gt; &lt;flags&gt; &lt;keyword/mask&gt;
        &lt;proc-name&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> removes a previously created
          bind</p>

          <p><strong>Returns:</strong> name of the command that was
          removed</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>binds [type/mask]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a list of Tcl binds, each item in the
          list is a sublist of five elements: {&lt;type&gt; &lt;flags&gt;
          &lt;name&gt; &lt;hits&gt; &lt;proc&gt;}</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>logfile [&lt;modes&gt; &lt;channel&gt;
        &lt;filename&gt;]</strong></dt>

        <dd>
          <p><strong>Description:</strong> creates a new logfile, which will
          log the modes given for the channel listed. If no logfile is
          specified, a list of existing logfiles will be returned.
          &quot;*&quot; indicates all channels. You can also change the
          modes and channel of an existing logfile with this command.
          Entering a blank mode and channel (&quot;&quot;) makes the bot
          stop logging there.</p>

          <p><strong>Returns:</strong> filename of logfile created, or, if
          no logfile is specified, a list of logfiles such as: {mco *
          eggdrop.log} {jp #lame lame.log}</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>maskhost &lt;nick!user@host&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> masked hostmask for the string
          given (&quot;n!u@1.2.3.4&quot; -&gt; &quot;*!u@1.2.3.*&quot;,
          &quot;n!u@lame.com&quot; -&gt; &quot;*!u@lame.com&quot;,
          &quot;n!u@a.b.edu&quot; -&gt; &quot;*!u@*.b.edu&quot;)</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>timer &lt;minutes&gt; &lt;tcl-command&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> executes the given Tcl command
          after a certain number of minutes have passed</p>

          <p><strong>Returns:</strong> a timerID</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>utimer &lt;seconds&gt; &lt;tcl-command&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> executes the given Tcl command
          after a certain number of seconds have passed</p>

          <p><strong>Returns:</strong> a timerID</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>timers</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a list of active minutely timers.
          Each entry in the list contains the number of minutes left till
          activation, the command that will be executed, and the timerID.</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>utimers</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a list of active secondly timers.
          Each entry in the list contains the number of minutes left till
          activation, the command that will be executed, and the timerID.</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>killtimer &lt;timerID&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> removes a minutely timer from
          the list</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>killutimer &lt;timerID&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> removes a secondly timer from
          the list</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>unixtime</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a long integer which represents the
          number of seconds that have passed since 00:00 Jan 1, 1970 (GMT).</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>duration &lt;seconds&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> the number of seconds converted
          into years, weeks, days, hours, minutes, and seconds. 804600
          seconds is turned into 1 week 2 days 7 hours 30 minutes.</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>strftime &lt;formatstring&gt; [time]</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a formatted string of time using
          standard strftime format. If time is specified, the value of the
          specified time is used. Otherwise, the current time is used.</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>ctime &lt;unixtime&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a formatted date/time string based
          on the current locale settings from the unixtime string given; for
          example &quot;Fri Aug 3 11:34:55 1973&quot;</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>myip</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a long number representing the
          bot&#39;s IP address, as it might appear in (for example) a DCC
          request</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>rand &lt;limit&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a random integer between 0 and
          limit-1</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>control &lt;idx&gt; &lt;command&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> removes an idx from the party line
          and sends all future input to the Tcl command given. The command
          will be called with two parameters: the idx and the input text.
          The command should return 0 to indicate success and 1 to indicate
          that it relinquishes control of the user back to the bot. If the
          input text is blank (&quot;&quot;), it indicates that the
          connection has been dropped. Also, if the input text is blank,
          never call killdcc on it, as it will fail with &quot;invalid
          idx&quot;.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>sendnote &lt;from&gt; &lt;to[@bot]&gt;
        &lt;message&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> simulates what happens when one
          user sends a note to another</p>

          <p><strong>Returns:</strong></p>

          <blockquote>
            <table>
              <tr valign="top">
                <td>
                  <p><strong>0</strong></p>
                </td>

                <td>
                  <p>the send failed</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>1</strong></p>
                </td>

                <td>
                  <p>the note was delivered locally or sent to another
                  bot</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>2</strong></p>
                </td>

                <td>
                  <p>the note was stored locally</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>3</strong></p>
                </td>

                <td>
                  <p>the user&#39;s notebox is too full to store a note</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>4</strong></p>
                </td>

                <td>
                  <p>a Tcl binding caught the note</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>5</strong></p>
                </td>

                <td>
                  <p>the note was stored because the user is away</p>
                </td>
              </tr>
            </table>
          </blockquote>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>link [via-bot] &lt;bot&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> attempts to link to another bot
          directly. If you specify a via-bot, it tells the via-bot to
          attempt the link.</p>

          <p><strong>Returns:</strong> 1 if the link will be attempted; 0
          otherwise</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>unlink &lt;bot&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> attempts to unlink a bot from
          the botnet</p>

          <p><strong>Returns:</strong> 1 on success; 0 otherwise</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>encrypt &lt;key&gt; &lt;string&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> encrypted string (using the currently
          loaded encryption module), encoded into ASCII using base-64</p>

          <p><strong>Module:</strong> encryption</p>
        </dd>

        <dt><strong>decrypt &lt;key&gt;
        &lt;encrypted-base64-string&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> decrypted string (using the
          currently loaded encryption module)</p>

          <p><strong>Module:</strong> encryption</p>
        </dd>

        <dt><strong>encpass &lt;password&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> encrypted string (using the currently
          loaded encryption module)</p>

          <p><strong>Module:</strong> encryption</p>
        </dd>

        <dt><strong>die [reason]</strong></dt>

        <dd>
          <p><strong>Description:</strong> causes the bot to log a fatal
          error and exit completely. If no reason is given,
          &quot;EXIT&quot; is used.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>unames</strong></dt>

        <dd>
          <p><strong>Returns:</strong> the current operating system the
          bot is using</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>dnslookup &lt;ip-address/hostname&gt; &lt;proc&gt;
        [[arg1] [arg2] ... [argN]]</strong></dt>

        <dd>
          <p><strong>Description:</strong> This issues an asynchronous dns
          lookup request. The command will block if dns module is not loaded;
          otherwise it will either return immediately or immediately call
          the specified proc (e.g. if the lookup is already cached).</p>

          <p>As soon as the request completes, the specified proc will be
          called as follows: &lt;proc&gt; &lt;ipaddress&gt; &lt;hostname&gt;
          &lt;status&gt; [[arg1] [arg2] ... [argN]]</p>

          <p>status is 1 if the lookup was successful and 0 if it
          wasn&#39;t. All additional parameters (called arg1, arg2 and argN
          above) get appended to the proc&#39;s other parameters.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>md5 &lt;string&gt;</strong></dt>

        <dd>
          <p><strong>Returns:</strong> the 128 bit MD5 message-digest of
          the specified string</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>callevent &lt;event&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> triggers the evnt bind manually
          for a certain event. For example: callevent rehash.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>traffic</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a list of sublists containing
          information about the bot&#39;s traffic usage in bytes. Each
          sublist contains five elements: type, in-traffic today,
          in-traffic total, out-traffic today, out-traffic total (in that
          order).</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>modules</strong></dt>

        <dd>
          <p><strong>Returns:</strong> a list of sublists containing
          information about the bot&#39;s currently loaded modules. Each
          sublist contains three elements: module, version, and
          dependencies. Each dependency is also a sublist containing the
          module name and version.</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>loadmodule &lt;module&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> attempts to load the specified
          module.</p>

          <p><strong>Returns:</strong> &quot;Already loaded.&quot; if the
          module is already loaded, &quot;&quot; if successful, or the
          reason the module couldn&#39;t be loaded.</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>unloadmodule &lt;module&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> attempts to unload the specified
          module.</p>

          <p><strong>Returns:</strong> &quot;No such module&quot; if the
          module is not loaded, &quot;&quot; otherwise.</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>loadhelp &lt;helpfile-name&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> attempts to load the specified
          help file from the help/ directory.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>unloadhelp &lt;helpfile-name&gt;</strong></dt>

        <dd>
          <p><strong>Description:</strong> attempts to unload the specified
          help file.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>reloadhelp</strong></dt>

        <dd>
          <p><strong>Description:</strong> reloads the bot&#39;s help
          files.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>restart</strong></dt>

        <dd>
          <p><strong>Description:</strong> rehashes the bot, kills all
          timers, reloads all modules, and reconnects the bot to the next
          server in its list.</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>rehash</strong></dt>

        <dd>
          <p><strong>Description:</strong> rehashes the bot</p>

          <p><strong>Returns:</strong> nothing</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>* stripcodes &lt;strip-flags&gt; &lt;string&gt;</strong></dt>
        <dd>
          <p><strong>Description:</strong> strips specified control characters
          from the string given. strip-flags can be any combination of the
          following:</p>

          <blockquote>
            <table>
              <tr valign="top">
                <td>
                  <p><strong>b</strong></p>
                </td>

                <td>
                  <p>remove all boldface codes</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>c</strong></p>
                </td>

                <td>
                  <p>remove all color codes</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>r</strong></p>
                </td>

                <td>
                  <p>remove all reverse video codes</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>u</strong></p>
                </td>

                <td>
                  <p>remove all underline codes</p>
                </td>
              </tr>


              <tr valign="top">
                <td>
                  <p><strong>a</strong></p>
                </td>

                <td>
                  <p>remove all ANSI codes</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>g</strong></p>
                </td>

                <td>
                  <p>remove all ctrl-g (bell) codes</p>
                </td>
              </tr>
            </table>
          </blockquote>

          <p><strong>Returns:</strong> the stripped string</p>

          <p><strong>Module:</strong> core</p>
        </dd>
      </dl>
    </blockquote>

    <p><a name="globvars"></a>10. <strong>Global variables</strong></p>

    <blockquote>
      <p><strong>NOTE:</strong> All config file variables are also global.</p>

      <dl>
        <dt><strong>botnick</strong></dt>

        <dd>
          <p><strong>Value:</strong> the current nickname the bot is using
          (for example: &quot;Valis&quot;, &quot;Valis0&quot;, etc.)</p>

          <p><strong>Module:</strong> server</p>
        </dd>

        <dt><strong>botname</strong></dt>

        <dd>
          <p><strong>Value:</strong> the current nick!user@host that the
          server sees (for example: &quot;Valis!valis@crappy.com&quot;)</p>

          <p><strong>Module:</strong> server</p>
        </dd>

        <dt><strong>server</strong></dt>

        <dd>
          <p><strong>Value:</strong> the current server&#39;s real name (what
          server calls itself) and port bot is connected to (for example:
          "irc.math.ufl.edu:6667") Note that this does not nececerilly match
          the servers internet address.</p>

          <p><strong>Module:</strong> server</p>
        </dd>

        <dt><strong>serveraddress</strong></dt>

        <dd>
          <p><strong>Value:</strong> the current server&#39;s internet address
          (hostname or IP) and port bot is connected to. This will correspond
          to the entry in server list (for example: "eu.undernet.org:6667").
          Note that this does not necessarily match the name server calls
          itself.</p>

          <p><strong>Module:</strong> server</p>
        </dd>

        <dt><strong>version</strong></dt>

        <dd>
          <p><strong>Value:</strong> current bot version &quot;1.1.2+pl1
          1010201 pl1&quot;; first item is the text version, second item
          is a numerical version, and any following items are the names of
          patches that have been added</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>numversion</strong></dt>

        <dd>
          <p><strong>Value:</strong> the current numeric bot version (for
          example: &quot;1010201&quot;). Numerical version is in the format
          of &quot;MNNRRPP&quot;, where:</p>

          <blockquote>
            <table>
              <tr valign="top">
                <td>
                  <p><strong>M</strong></p>
                </td>

                <td>
                  <p>major release number</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>NN</strong></p>
                </td>

                <td>
                  <p>minor release number</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>RR</strong></p>
                </td>

                <td>
                  <p>sub-release number</p>
                </td>
              </tr>

              <tr valign="top">
                <td>
                  <p><strong>PP</strong></p>
                </td>

                <td>
                  <p>patch level for that sub-release</p>
                </td>
              </tr>
            </table>
          </blockquote>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>uptime</strong></dt>

        <dd>
          <p><strong>Value:</strong> the unixtime value for when the bot
          was started</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>server-online</strong></dt>

        <dd>
          <p><strong>Value:</strong> the unixtime value for when the bot
          connected to its current server</p>

          <p><strong>Module:</strong> server</p>
        </dd>

        <dt><strong>lastbind</strong></dt>

        <dd>
          <p><strong>Value:</strong> the last command binding which was
          triggered. This allows you to identify which command triggered
          a Tcl proc.</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>isjuped</strong></dt>

        <dd>
          <p><strong>Value:</strong> 1 if bot&#39;s nick is juped(437);
          0 otherwise</p>

          <p><strong>Module:</strong> server</p>
        </dd>

        <dt><strong>handlen</strong></dt>

        <dd>
          <p><strong>Value:</strong> the value of the HANDLEN define in
          src/eggdrop.h</p>

          <p><strong>Module:</strong> core</p>
        </dd>

        <dt><strong>config</strong></dt>

        <dd>
          <p><strong>Value:</strong> the filename of the config file Eggdrop
          is currently using</p>

          <p><strong>Module:</strong> core</p>
        </dd>
      </dl>
    </blockquote>

    <p><a name="bind"></a>11. <strong>Bind</strong></p>

    <blockquote>
      <p>You can use the &#39;bind&#39; command to attach Tcl procedures
      to certain events. For example, you can write a Tcl procedure that
      gets called every time a user says &quot;danger&quot; on the
      channel.</p>

      <p>Some bind types are marked as &quot;stackable&quot;. That means
      that you can bind multiple commands to the same trigger. Normally, for
      example, a bind such as &#39;bind msg - stop msg:stop&#39; (which
      makes a msg-command &quot;stop&quot; call the Tcl proc
      &quot;msg:stop&quot;) will overwrite any previous binding you had for
      then msg command &quot;stop&quot;. With stackable bindings, like
      &#39;msgm&#39; for example, you can bind the same command to multiple
      procs. When the bind is triggered, ALL of the Tcl procs that are
      bound to it will be called.</p>

      <p>To remove a bind, use the &#39;unbind&#39; command. For example,
      to remove the bind for the &quot;stop&quot; msg command, use
      &#39;unbind msg - stop msg:stop&#39;.</p>

      <ol type="A">
        <li>
          <p><a name="binda"></a><strong>Bind types</strong></p>

          <ol>
            <li>
              <p><strong>MSG</strong></p>

              <p><strong>bind msg &lt;flags&gt; &lt;command&gt;
              &lt;proc&gt;<br>
              procname &lt;nick&gt; &lt;user@host&gt; &lt;handle&gt;
              &lt;text&gt;</strong></p>

              <p><strong>Description:</strong> used for /msg commands. The
              first word of the user&#39;s msg is the command, and
              everything else becomes the text argument.</p>

              <p><strong>Module:</strong> server</p>
            </li>

            <li>
              <p><strong>DCC</strong></p>

              <p><strong>bind dcc &lt;flags&gt; &lt;command&gt;
              &lt;proc&gt;<br>
              procname &lt;handle&gt; &lt;idx&gt; &lt;text&gt;</strong></p>

              <p><strong>Description:</strong> used for partyline commands;
              the command is the first word and everything else becomes
              the text argument. The idx is valid until the user disconnects.
              After that, it may be reused, so be careful about storing an
              idx for long periods of time.</p>

              <p><strong>Module:</strong> core</p>
            </li>

            <li>
              <p><strong>FIL</strong></p>

              <p><strong>bind fil &lt;flags&gt; &lt;command&gt;
              &lt;proc&gt;<br>
              procname &lt;handle&gt; &lt;idx&gt; &lt;text&gt;</strong></p>

              <p><strong>Description:</strong> the same as DCC, except this
              is triggered if the user is in the file area instead of the
              party line</p>

              <p><strong>Module:</strong> filesys</p>
            </li>

            <li>
              <p><strong>PUB</strong></p>

              <p><strong>bind pub &lt;flags&gt; &lt;command&gt;
              &lt;proc&gt;<br>
              procname &lt;nick&gt; &lt;user@host&gt; &lt;handle&gt;
              &lt;channel&gt; &lt;text&gt;</strong></p>

              <p><strong>Description:</strong> used for commands given on
              a channel. The first word becomes the command and everything
              else is the text argument.</p>

              <p><strong>Module:</strong> irc</p>
            </li>

            <li>
              <p><strong>MSGM (stackable)</strong></p>

              <p><strong>bind msgm &lt;flags&gt; &lt;mask&gt;
              &lt;proc&gt;<br>
              procname &lt;nick&gt; &lt;user@host&gt; &lt;handle&gt;
              &lt;text&gt;</strong></p>

              <p><strong>Description:</strong> matches the entire line of
              text from a /msg with the mask. This is useful for binding
              Tcl procs to words or phrases spoken anywhere within a line
              of text.</p>

              <p><strong>Module:</strong> server</p>
            </li>

            <li>
              <p><strong>PUBM (stackable)</strong></p>

              <p><strong>bind pubm &lt;flags&gt; &lt;mask&gt;
              &lt;proc&gt;<br>
              procname &lt;nick&gt; &lt;user@host&gt; &lt;handle&gt;
              &lt;channel&gt; &lt;text&gt;</strong></p>

              <p><strong>Description:</strong> just like MSGM, except
              it&#39;s triggered by things said on a channel instead of
              things /msg&#39;d to the bot. The mask is matched against
              the channel name followed by the text and can contain
              wildcards. Also, if a line triggers a PUB bind, it will not
              trigger a PUBM bind.</p>

              <p><strong>Module:</strong> irc</p>
            </li>

            <li>
              <p><strong>NOTC (stackable)</strong></p>

              <p><strong>bind notc &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              procname &lt;nick&gt; &lt;user@host&gt; &lt;handle&gt;
              &lt;text&gt; &lt;dest&gt;</strong></p>

              <p><strong>Description:</strong> dest will be a nickname (the
              bot&#39;s nickname, obviously) or a channel name. mask is
              matched against the entire notice and can contain wildcards.
              It is considered a breach of protocol to respond to a /notice
              on IRC, so this is intended for internal use (logging, etc.)
              only.Note that server notices do not trigger the NOTC bind.</p>

              <p>New Tcl procs should be declared as</p>

<pre>
  proc notcproc {nick uhost hand text {dest &quot;&quot;}} {
    global botnick; if {$dest == &quot;&quot;} {set dest $botnick}
    ...
  }
</pre>

              <p>for compatibility.</p>

              <p><strong>Module:</strong> server</p>
            </li>

            <li>
              <p><strong>JOIN (stackable)</strong></p>

              <p><strong>bind join &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              procname &lt;nick&gt; &lt;user@host&gt; &lt;handle&gt;
              &lt;channel&gt;</strong></p>

              <p><strong>Description:</strong> triggered by someone joining
              the channel. The mask in the bind is matched against
              &quot;#channel nick!user@host&quot; and can contain
              wildcards.</p>

              <p><strong>Module:</strong> irc</p>
            </li>

            <li>
              <p><strong>PART (stackable)</strong></p>

              <p><strong>bind part &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              procname &lt;nick&gt; &lt;user@host&gt; &lt;handle&gt;
              &lt;channel&gt; &lt;msg&gt;</strong></p>

              <p><strong>Description:</strong> triggered by someone leaving
              the channel. The mask is matched against &quot;#channel
              nick!user@host&quot; and can contain wildcards. If no part
              message is specified, msg will be set to &quot;&quot;.</p>

              <p>New Tcl procs should be declared as</p>

<pre>
  proc partproc {nick uhost hand chan {msg &quot;&quot;}} { ... }
</pre>

              <p>for compatibility.</p>

              <p><strong>Module:</strong> irc</p>
            </li>

            <li>
              <p><strong>SIGN (stackable)</strong></p>

              <p><strong>bind sign &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              procname &lt;nick&gt; &lt;user@host&gt; &lt;handle&gt;
              &lt;channel&gt; &lt;reason&gt;</strong></p>

              <p><strong>Description:</strong> triggered by a signoff, or
              possibly by someone who got netsplit and never returned. The
              signoff message is the last argument to the proc. Wildcards
              can be used in the mask, which is matched against &#39;#channel
              nick!user@host&#39;.</p>

              <p><strong>Module:</strong> irc</p>
            </li>

            <li>
              <p><strong>TOPC (stackable)</strong></p>

              <p><strong>bind topc &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              procname &lt;nick&gt; &lt;user@host&gt; &lt;handle&gt;
              &lt;channel&gt; &lt;topic&gt;</strong></p>

              <p><strong>Description:</strong> triggered by a topic change.
              mask can contain wildcards and is matched against &#39;#channel
              &lt;new topic&gt;&#39;.</p>

              <p><strong>Module:</strong> irc</p>
            </li>

            <li>
              <p><strong>KICK (stackable)</strong></p>

              <p><strong>bind kick &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              procname &lt;nick&gt; &lt;user@host&gt; &lt;handle&gt;
              &lt;channel&gt; &lt;target&gt; &lt;reason&gt;</strong></p>

              <p><strong>Description:</strong> triggered when someone is
              kicked off the channel. The mask is matched against
              &#39;#channel target reason&#39; where the target is the nickname of
              the person who got kicked (can contain wildcards). The proc
              is called with the nick, user@host, and handle of the kicker,
              plus the channel, the nickname of the person who was kicked,
              and the reason; flags are ignored.</p>

              <p><strong>Module:</strong> irc</p>
            </li>

            <li>
              <p><strong>NICK (stackable)</strong></p>

              <p><strong>bind nick &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              procname &lt;nick&gt; &lt;user@host&gt; &lt;handle&gt;
              &lt;channel&gt; &lt;newnick&gt;</strong></p>

              <p><strong>Description:</strong> triggered when someone changes
              nicknames. The mask is matched against &#39;#channel newnick&#39;
              and can contain wildcards. Channel is "*" if the user isn&#39;t
              on a channel (usually the bot not yet in a channel).</p>

              <p><strong>Module:</strong> irc</p>
            </li>

            <li>
              <p><strong>MODE (stackable)</strong></p>

              <p><strong>bind mode &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              proc-name &lt;nick&gt; &lt;user@host&gt; &lt;handle&gt;
              &lt;channel&gt; &lt;mode-change&gt; &lt;victim&gt;</strong></p>

              <p><strong>Description:</strong> mode changes are broken down
              into their component parts before being sent here, so the
              &lt;mode-change&gt; will always be a single mode, such as
              &quot;+m&quot; or &quot;-o&quot;. victim will show the argument
              of the mode change (for o/v/b/e/I) or &quot;&quot; if the set
              mode does not take an argument. Flags are ignored. The
              bot&#39;s automatic response to a mode change will happen
              AFTER all matching Tcl procs are called. The mask will be
              matched against &#39;#channel +/-modes&#39; and can
              contain wildcards.</p>

              <p>If it is a server mode, nick will be &quot;&quot;, user@host
              is the server name, and handle is *.</p>

              <p>Note that &quot;victim&quot; was added in 1.3.23 and that
              this will break Tcl scripts that were written for pre-1.3.23
              versions and use this binding. An easy fix (by guppy) is as
              follows (example):</p>

              <p>Old script looks as follows:</p>

<pre>
  bind mode - * mode_proc
  proc mode_proc {nick uhost hand chan mc} { ... }
</pre>

              <p>To make it work with 1.3.23+ and stay compatible with older
              bots, do:</p>

<pre>
  bind mode - * mode_proc_fix
  proc mode_proc_fix {nick uhost hand chan mc {victim &quot;&quot;}} {
    if {$victim != &quot;&quot;} {append mc &quot; $victim&quot;}
    mode_proc $nick $uhost $hand $chan $mc
  }
  proc mode_proc {nick uhost hand chan mc} { ... }
</pre>

              <p><strong>Module:</strong> irc</p>
            </li>

            <li>
              <p><strong>CTCP (stackable)</strong></p>

              <p><strong>bind ctcp &lt;flags&gt; &lt;keyword&gt;
              &lt;proc&gt;<br>
              proc-name &lt;nick&gt; &lt;user@host&gt; &lt;handle&gt;
              &lt;dest&gt; &lt;keyword&gt; &lt;text&gt;</strong></p>

              <p><strong>Description:</strong> dest will be a nickname (the
              bot&#39;s nickname, obviously) or channel name. keyword is
              the ctcp command (which can contain wildcards), and text may
              be empty. If the proc returns 0, the bot will attempt its
              own processing of the ctcp command.</p>

              <p><strong>Module:</strong> server</p>
            </li>

            <li>
              <p><strong>CTCR (stackable)</strong></p>

              <p><strong>bind ctcr &lt;flags&gt; &lt;keyword&gt;
              &lt;proc&gt;<br>
              proc-name &lt;nick&gt; &lt;user@host&gt; &lt;handle&gt;
              &lt;dest&gt; &lt;keyword&gt; &lt;text&gt;</strong></p>

              <p><strong>Description:</strong> just like ctcp, but this is
              triggered for a ctcp-reply (ctcp embedded in a notice instead
              of a privmsg)</p>

              <p><strong>Module:</strong> server</p>
            </li>

            <li>
              <p><strong>RAW (stackable)</strong></p>

              <p><strong>bind raw &lt;flags&gt; &lt;keyword-mask&gt;
              &lt;proc&gt;<br>
              procname &lt;from&gt; &lt;keyword&gt; &lt;text&gt;</strong></p>

              <p><strong>Description:</strong> previous versions of Eggdrop
              required a special compile option to enable this binding, but
              it&#39;s now standard. The keyword is either a numeric, like
              &quot;368&quot;, or a keyword, such as &quot;PRIVMSG&quot;. from
              will be the server name or the source user (depending on the
              keyword); flags are ignored. The order of the arguments is
              identical to the order that the IRC server sends to the bot. The
              pre-processing  only splits it apart enough to determine the
              keyword. If the proc returns 1, Eggdrop will not process the line
              any further (this could cause unexpected behavior in some
              cases).</p>

              <p><strong>Module:</strong> server</p>
            </li>

            <li>
              <p><strong>BOT</strong></p>

              <p><strong>bind bot &lt;flags&gt; &lt;command&gt;
              &lt;proc&gt;<br>
              proc-name &lt;from-bot&gt; &lt;command&gt;
              &lt;text&gt;</strong></p>

              <p><strong>Description:</strong> triggered by a message coming
              from another bot in the botnet. The first word is the command
              and the rest becomes the text argument; flags are ignored.</p>

              <p><strong>Module:</strong> core</p>
            </li>
            <li>
              <p><strong>CHON (stackable)</strong></p>

              <p><strong>bind chon &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              proc-name &lt;handle&gt; &lt;idx&gt;</strong></p>

              <p><strong>Description:</strong> when someone first enters the
              party-line area of the bot via dcc chat or telnet, this is
              triggered before they are connected to a chat channel (so,
              yes, you can change the channel in a &#39;chon&#39; proc).
              mask is matched against the handle and supports wildcards.
              This is NOT triggered when someone returns from the file area,
              etc.</p>

              <p><strong>Module:</strong> core</p>
            </li>

            <li>
              <p><strong>CHOF (stackable)</strong></p>

              <p><strong>bind chof &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              proc-name &lt;handle&gt; &lt;idx&gt;</strong></p>

              <p><strong>Description:</strong> triggered when someone leaves
              the party line to disconnect from the bot. mask is matched
              against the handle and can contain wildcards. Note that the
              connection may have already been dropped by the user, so
              don&#39;t send output to the idx.</p>

              <p><strong>Module:</strong> core</p>
            </li>

            <li>
              <p><strong>SENT (stackable)</strong></p>

              <p><strong>bind sent &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              proc-name &lt;handle&gt; &lt;nick&gt;
              &lt;path/to/file&gt;</strong></p>

              <p><strong>Description:</strong> after a user has successfully
              downloaded a file from the bot, this binding is triggered. mask
              is matched against the handle of the user that initiated the
              transfer and supports wildcards. nick is the actual recipient
              (on IRC) of the file. The path is relative to the dcc
              directory (unless the file transfer was started by a script
              call to &#39;dccsend&#39;, in which case the path is the
              exact path given in the call to &#39;dccsend&#39;).</p>

              <p><strong>Module:</strong> transfer</p>
            </li>

            <li>
              <p><strong>RCVD (stackable)</strong></p>

              <p><strong>bind rcvd &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              proc-name &lt;handle&gt; &lt;nick&gt;
              &lt;path/to/file&gt;</strong></p>

              <p><strong>Description:</strong> triggered after a user
              uploads a file successfully. mask is matched against the
              user&#39;s handle. nick is the IRC nickname that the file
              transfer originated from. The path is where the file ended
              up, relative to the dcc directory (usually this is your
              incoming dir).</p>

              <p><strong>Module:</strong> transfer</p>
            </li>

            <li>
              <p><strong>*  CHAT (stackable)</strong></p>

              <p><strong>bind chat &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              proc-name &lt;handle&gt; &lt;channel#&gt;
              &lt;text&gt;</strong></p>

              <p><strong>Description:</strong> when a user says something on
              the botnet, it invokes this binding. Flags are ignored; handle
              could be a user on this bot (&quot;DronePup&quot;) or on
              another bot (&quot;Eden@Wilde&quot;) and therefore you can&#39;t
              rely on a local user record. The mask is checked against the
              entire line of text and supports wildcards.</p>

              <p><strong>NOTE:</strong> If a BOT says something on the botnet,
              the BCST bind is invoked instead.</p>

              <p><strong>Module:</strong> core</p>
            </li>

            <li>
              <p><strong>LINK (stackable)</strong></p>

              <p><strong>bind link &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              proc-name &lt;botname&gt; &lt;via&gt;</strong></p>

              <p><strong>Description:</strong> triggered when a bot links
              into the botnet. botname is the botnetnick of the bot that
              just linked in; via is the bot it linked through. The mask
              is checked against the botnetnick of the bot that linked and
              supports wildcards. flags are ignored.</p>

              <p><strong>Module:</strong> core</p>
            </li>

            <li>
              <p><strong>DISC (stackable)</strong></p>

              <p><strong>bind disc &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              proc-name &lt;botname&gt;</strong></p>

              <p><strong>Description:</strong> triggered when a bot
              disconnects from the botnet for whatever reason. Just like
              the link bind, flags are ignored; mask is matched against
              the botnetnick of the bot that unlinked. Wildcards are
              supported in mask.</p>

              <p><strong>Module:</strong> core</p>
            </li>

            <li>
              <p><strong>SPLT (stackable)</strong></p>

              <p><strong>bind splt &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              procname &lt;nick&gt; &lt;user@host&gt; &lt;handle&gt;
              &lt;channel&gt;</strong></p>

              <p><strong>Description:</strong> triggered when someone gets
              netsplit on the channel. Be aware that this may be a false
              alarm (it&#39;s easy to fake a netsplit signoff message on
              some networks); mask may contain wildcards and is matched
              against &#39;#channel nick!user@host&#39;. Anyone who is SPLT
              will trigger a REJN or SIGN within the next wait-split
              (defined in the config file) minutes.</p>

              <p><strong>Module:</strong> irc</p>
            </li>

            <li>
              <p><strong>REJN (stackable)</strong></p>

              <p><strong>bind rejn &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              procname &lt;nick&gt; &lt;user@host&gt; &lt;handle&gt;
              &lt;channel&gt;</strong></p>

              <p><strong>Description:</strong> someone who was split has
              rejoined. mask can contain wildcards, and is matched against
              &#39;#channel nick!user@host&#39;.</p>

              <p><strong>Module:</strong> irc</p>
            </li>

            <li>
              <p><strong>FILT (stackable)</strong></p>

              <p><strong>bind filt &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              procname &lt;idx&gt; &lt;text&gt;</strong></p>

              <p><strong>Description:</strong> party line and file system
              users have their text sent through filt before being
              processed. If the proc returns a blank string, the text is
              considered parsed. Otherwise, the bot will use the text
              returned from the proc and continue parsing that.</p>

              <p><strong>Module:</strong> core</p>
            </li>

            <li>
              <p><strong>NEED (stackable)</strong></p>

              <p><strong>bind need &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              procname &lt;channel&gt; &lt;type&gt;</strong></p>

              <p><strong>Description:</strong> this bind is triggered on
              certain events, like when the bot needs operator status or
              the key for a channel. The types are: op, unban, invite,
              limit, and key; the mask is matched against &#39;#channel
              type&#39; and can contain wildcards. flags are ignored.</p>

              <p>Example:</p>

              <p>bind need - &quot;% op&quot; needop &lt; handles only need
              op<br>
              bind need - &quot;*&quot; needall   &lt; handles all needs</p>

              <p><strong>Module:</strong> irc</p>
            </li>

            <li>
              <p><strong>FLUD (stackable)</strong></p>

              <p><strong>bind flud &lt;flags&gt; &lt;type&gt; &lt;proc&gt;<br>
              procname &lt;nick&gt; &lt;user@host&gt; &lt;handle&gt;
              &lt;type&gt; &lt;channel&gt;</strong></p>

              <p><strong>Description:</strong> any floods detected through
              the flood control settings (like &#39;flood-ctcp&#39;) are
              sent here before processing. If the proc returns 1, no
              further action is taken on the flood; if the proc returns 0,
              the bot will do its normal &quot;punishment&quot; for the
              flood. The flood types are: pub, msg, join, or ctcp (and can
              be masked to &quot;*&quot; for the bind); flags are ignored.</p>

              <p><strong>Module:</strong> server</p>
            </li>

            <li>
              <p><strong>NOTE</strong></p>

              <p><strong>bind note &lt;flags&gt; &lt;handle&gt; &lt;proc&gt;<br>
              procname &lt;from&gt; &lt;to&gt; &lt;text&gt;</strong></p>

              <p><strong>Description:</strong> incoming notes (either from
              the party line, someone on IRC, or someone on another bot on
              the botnet) are checked against these binds before being
              processed. If a bind exists, the bot will not deliver the
              note. The handle must be an exact match (no wildcards), but
              it is not case sensitive; flags are ignored.</p>

              <p><strong>Module:</strong> core</p>
            </li>

            <li>
              <p><strong>ACT (stackable)</strong></p>

              <p><strong>bind act &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              proc-name &lt;handle&gt; &lt;channel#&gt;
              &lt;action&gt;</strong></p>

              <p><strong>Description:</strong> when someone does an action
              on the botnet, it invokes this binding. flags are ignored;
              the mask is matched against the text of the action and can
              support wildcards.</p>

              <p><strong>Module:</strong> core</p>
            </li>

            <li>
              <p><strong>WALL (stackable)</strong></p>

              <p><strong>bind wall &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              proc-name &lt;handle&gt; &lt;msg&gt;</strong></p>

              <p><strong>Description:</strong> when the bot receives a
              wallops, it invokes this binding. flags are ignored; the
              mask is matched against the text of the wallops msg.</p>

              <p><strong>Module:</strong> server</p>
            </li>

            <li>
              <p><strong>* BCST (stackable)</strong></p>

              <p><strong>bind bcst &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              proc-name &lt;botname&gt; &lt;channel#&gt;
              &lt;text&gt;</strong></p>

              <p><strong>Description:</strong> when a bot broadcasts something
              on the botnet (see &#39;dccbroadcast&#39; above), it invokes
              this binding. flags are ignored; the mask is matched against
              the message text and can contain wildcards. &#39;channel&#39;
              argument will always be &#39;-1&#39; since broadcasts are not
              directed to any partyline channel.</p>

              <p>It is also invoked when a BOT (not a person, as with the CHAT
              bind) &#39;says&#39; something on a channel. In this case, the
              &#39;channel&#39; argument will be a valid channel, and not
              &#39;-1&#39;.

              <p><strong>Module:</strong> core</p>
            </li>

            <li>
              <p><strong>CHJN (stackable)</strong></p>

              <p><strong>bind chjn &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              proc-name &lt;botname&gt; &lt;handle&gt; &lt;channel#&gt;
              &lt;flag&gt; &lt;idx&gt; &lt;user@host&gt;</strong></p>

              <p><strong>Description:</strong> when someone joins a botnet
              channel, it invokes this binding. The mask is matched against
              the channel and can contain wildcards. flag is one of: *
              (owner), + (master), @ (op), or % (botnet master).</p>

              <p><strong>Module:</strong> core</p>
            </li>

            <li>
              <p><strong>CHPT (stackable)</strong></p>

              <p><strong>bind chpt &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              proc-name &lt;botname&gt; &lt;handle&gt; &lt;idx&gt;
              &lt;channel#&gt;</strong></p>

              <p><strong>Description:</strong> when someone parts a botnet
              channel, it invokes this binding. flags are ignored; the mask
              is matched against the channel and can contain wildcards.</p>

              <p><strong>Module:</strong> core</p>
            </li>

            <li>
              <p><strong>TIME (stackable)</strong></p>

              <p><strong>bind time &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              proc-name &lt;minute&gt; &lt;hour&gt; &lt;day&gt; &lt;month&gt;
              &lt;year&gt;</strong></p>

              <p><strong>Description:</strong> allows you to schedule
              procedure calls at certain times. mask matches 5 space
              separated integers of the form: &quot;minute hour day month
              year&quot;. minute, hour, day, month have a zero padding so
              they are exactly two characters long; year is extended to
              four characters in the same way. flags are ignored.</p>

              <p><strong>Module:</strong> core</p>
            </li>

            <li>
              <p><strong>AWAY (stackable)</strong></p>

              <p><strong>bind away &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              proc-name &lt;botname&gt; &lt;idx&gt; &lt;text&gt;</strong></p>

              <p><strong>Description:</strong> triggers when a user goes
              away or comes back on the botnet. text is the reason than has
              been specified (text is &quot;&quot; when returning). mask is
              matched against the botnet-nick of the bot the user is
              connected to and supports wildcards. flags are ignored.</p>

              <p><strong>Module:</strong> core</p>
            </li>

            <li>
              <p><strong>LOAD (stackable)</strong></p>

              <p><strong>bind load &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              proc-name &lt;module&gt;</strong></p>

              <p><strong>Description:</strong> triggers when a module is
              loaded. mask is matched against the name of the loaded module
              and supports wildcards; flags are ignored.</p>

              <p><strong>Module:</strong> core</p>
            </li>

            <li>
              <p><strong>UNLD (stackable)</strong></p>

              <p><strong>bind unld &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              proc-name &lt;module&gt;</strong></p>

              <p><strong>Description:</strong> triggers when a module is
              unloaded. mask is matched against the name of the unloaded
              module and supports wildcards; flags are ignored.</p>

              <p><strong>Module:</strong> core</p>
            </li>

            <li>
              <p><strong>NKCH (stackable)</strong></p>

              <p><strong>bind nkch &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              proc-name &lt;oldhandle&gt; &lt;newhandle&gt;</strong></p>

              <p><strong>Description:</strong> triggered whenever a local
              user&#39;s handle is changed (in the userfile). mask is
              matched against the user&#39;s old handle and can contain
              wildcards; flags are ignored.</p>

              <p><strong>Module:</strong> core</p>
            </li>

            <li>
              <p><strong>EVNT (stackable)</strong></p>

              <p><strong>bind evnt &lt;flags&gt; &lt;type&gt; &lt;proc&gt;<br>
              proc-name &lt;type&gt;</strong></p>

              <p><strong>Description:</strong> Description: triggered whenever
              one of these events happen; flags are ignored; valid events
              are:</p>

              <blockquote>
                <table>
                  <tr valign="top">
                    <td>
                      <p><strong>sighup</strong></p>
                    </td>

                    <td>
                      <p>called on a kill -HUP &lt;pid&gt;</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td>
                      <p><strong>sigterm</strong></p>
                    </td>

                    <td>
                      <p>called on a kill -TERM &lt;pid&gt;</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td>
                      <p><strong>sigill</strong></p>
                    </td>

                    <td>
                      <p>called on a kill -ILL &lt;pid&gt;</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td>
                      <p><strong>sigquit</strong></p>
                    </td>

                    <td>
                      <p>called on a kill -QUIT &lt;pid&gt;</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td>
                      <p><strong>save</strong></p>
                    </td>

                    <td>
                      <p>called when the userfile is saved</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td>
                      <p><strong>rehash</strong></p>
                    </td>

                    <td>
                      <p>called just after a rehash</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td>
                      <p><strong>prerehash</strong></p>
                    </td>

                    <td>
                      <p>called just before a rehash</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td>
                      <p><strong>prerestart</strong></p>
                    </td>

                    <td>
                      <p>called just before a restart</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td>
                      <p><strong>logfile</strong></p>
                    </td>

                    <td>
                      <p>called when the logs are switched daily</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td>
                      <p><strong>loaded</strong></p>
                    </td>

                    <td>
                      <p>called when the bot is done loading</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td>
                      <p><strong>userfile-loaded</strong></p>
                    </td>

                    <td>
                      <p>called after userfile has been loaded</p>
                    </td>
                  </tr>
                </table>
              </blockquote>

              <blockquote>
                <table>
                  <tr valign="top">
                    <td>
                      <p><strong>connect-server</strong></p>
                    </td>

                    <td>
                      <p>called just before we connect to an IRC server</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td>
                      <p><strong>init-server</strong></p>
                    </td>

                    <td>
                      <p>called when we actually get on our IRC server</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td>
                      <p><strong>disconnect-server</strong></p>
                    </td>

                    <td>
                      <p>called when we disconnect from our IRC server</p>
                    </td>
                  </tr>
                </table>
              </blockquote>

              <p><strong>Module:</strong> core</p>
            </li>

            <li>
              <p><strong>LOST (stackable)</strong></p>

              <p><strong>bind lost &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              proc-name &lt;handle&gt; &lt;nick&gt; &lt;path&gt;
              &lt;bytes-transferred&gt; &lt;length-of-file&gt;</strong></p>

              <p><strong>Description:</strong> triggered when a DCC SEND
              transfer gets lost, such as when the connection is
              terminated before all data was successfully sent/received.
              This is typically caused by a user abort.</p>

              <p><strong>Module:</strong> transfer</p>
            </li>

            <li>
              <p><strong>TOUT (stackable)</strong></p>

              <p><strong>bind tout &lt;flags&gt; &lt;mask&gt; &lt;proc&gt;<br>
              proc-name &lt;handle&gt; &lt;nick&gt; &lt;path&gt;
              &lt;bytes-transferred&gt; &lt;length-of-file&gt;</strong></p>

              <p><strong>Description:</strong> triggered when a DCC SEND
              transfer times out. This may either happen because the dcc
              connection was not accepted or because the data transfer
              stalled for some reason.</p>

              <p><strong>Module:</strong> transfer</p>
            </li>
          </ol>
        </li>

        <li>
          <p><a name="bindb"></a><strong>Return Values</strong></p>

          <p>Several bindings pay attention to the value you return from
          the proc (using &#39;return &lt;value&gt;&#39;). Usually, they
          expect a 0 or 1, and returning an empty return is interpreted
          as a 0. Be aware if you omit the return statement, the result
          of the last Tcl command executed will be returned by the proc.
          This will not likely produce the results you intended (this is
          a &quot;feature&quot; of Tcl).</p>

          <p>Here&#39;s a list of the bindings that use the return value
          from procs they trigger:</p>

          <ol>
            <li>
              <p><strong>MSG</strong>

              <p>Return 1 to make the command get logged like so:</p>

              <blockquote>
                <p>(nick!user@host) !handle! command</p>
              </blockquote>
            </li>

            <li>
              <p><strong>DCC</strong>

              <p>Return 1 to make the command get logged like so:</p>

              <blockquote>
                <p>#handle# command</p>
              </blockquote>
            </li>

            <li>
              <p><strong>FIL</strong>

              <p>Return 1 to make the command get logged like so:</p>

              <blockquote>
                <p>#handle# files: command</p>
              </blockquote>
            </li>

            <li>
              <p><strong>PUB</strong>

              <p>Return 1 to make the command get logged like so:</p>

              <blockquote>
                <p>&lt;&lt;nick&gt;&gt; !handle! command</p>
              </blockquote>
            </li>

            <li>
              <p><strong>CTCP</strong>

              <p>Return 1 to ask the bot not to process the CTCP command on
              its own. Otherwise, it would send its own response to the CTCP
              (possibly an error message if it doesn&#39;t know how to deal
              with it).</p>
            </li>

            <li>
              <p><strong>FILT</strong>

              <p>Return "" to indicate the text has been processed, and the
              bot should just ignore it. Otherwise, it will treat the text
              like any other.</p>
            </li>

            <li>
              <p><strong>FLUD</strong>

              <p>Return 1 to ask the bot not to take action on the flood.
              Otherwise it will do its normal punishment.</p>
            </li>

            <li>
              <p><strong>RAW</strong>

              <p>Return 1 to ask the bot not to process the server text.
              This can affect the bot&#39;s performance by causing it to
              miss things that it would normally act on -- you have been
              warned.</p>
            </li>

            <li>
              <p><strong>CHON</strong>

              <p>Return 1 to ask the bot not to process the partyline join
              event.</p>
            </li>

            <li>
              <p><strong>CHOF</strong>

              <p>Return 1 to ask the bot not to process the partyline part
              event.</p>
            </li>

            <li>
              <p><strong>WALL</strong>

              <p>Return 1 to make the command get logged like so:</p>

              <blockquote>
                <p>!nick! msg</p>
              </blockquote>
            </li>
          </ol>
        </li>
      </ol>
    </blockquote>

    <p><a name="control"></a>12. <strong>Control procedures</strong></p>

    <blockquote>
      <p>Using the &#39;control&#39; command, you can put a DCC connection
      (or outgoing TCP connection) in control of a script. All text received
      from the connection is sent to the proc you specify. All outgoing text
      should be sent with &#39;putdcc&#39;.</p>

      <p>The control procedure is called with these parameters:</p>

      <blockquote>
        <p>procname &lt;idx&gt; &lt;input-text&gt;</p>
      </blockquote>

      <p>This allows you to use the same proc for several connections. The
      idx will stay the same until the connection is dropped. After that,
      it will probably get reused for a later connection.</p>

      <p>To indicate that the connection has closed, your control procedure
      will be called with blank text (the input-text will be &quot;&quot;).
      This is the only time it will ever be called with &quot;&quot; as the
      text, and it is the last time your proc will be called for that
      connection. Don&#39;t call killdcc on the idx when text is blank, it
      will always fail with &quot;invalid idx&quot;.</p>

      <p>If you want to hand control of your connection back to Eggdrop,
      your  proc should return 1. Otherwise, return 0 to retain
      control.</p>
    </blockquote>

    <p><a name="tcp"></a>13. <strong>TCP connections</strong></p>

    <blockquote>
      <p>Eggdrop allows you to make two types of TCP (&quot;telnet&quot;)
      connections: outgoing and incoming. For an outgoing connection, you
      specify the remote host and port to connect to. For an incoming
      connection, you specify a port to listen on.</p>

      <p>All of the connections are *event driven*. This means that the bot
      will trigger your procs when something happens on the connection, and
      your proc is expected to return as soon as possible. Waiting in a proc
      for more input is a no-no.</p>

      <p>To initiate an outgoing connection, use:</p>

      <blockquote>
        <p>set idx [connect &lt;hostname&gt; &lt;port&gt;]</p>
      </blockquote>

      <p>$idx now contains a new DCC entry for the outgoing connection.</p>

      <p>All connections use non-blocking (commonly called
      &quot;asynchronous&quot;, which is a misnomer) I/O. Without going
      into a big song and dance about asynchronous I/O, what this means
      to you is:</p>

      <ul>
        <li>
          <p>assume the connection succeeded immediately</p>
        </li>

        <li>
          <p>if the connection failed, an EOF will arrive for that idx</p>
        </li>
      </ul>

      <p>The only time a &#39;connect&#39; will return an error is if you
      give it a hostname that can&#39;t be resolved (this is considered a
      &quot;DNS error&quot;). Otherwise, it will appear to have succeeded.
      If the connection failed, you will immediately get an EOF.</p>

      <p>Right after doing a &#39;connect&#39; call, you should set up a
      &#39;control&#39; for the new idx (see the section above). From then
      on, the connection will act just like a normal DCC connection that
      has been put under the control of a script. If you ever return
      &quot;1&quot; from the control proc (indicating that you want control
      to return to Eggdrop), the bot will just close the connection and
      dispose of it. Other commands that work on normal DCC connections,
      like &#39;killdcc&#39; and &#39;putdcc&#39;, will work on this idx,
      too. The &#39;killdcc&#39; command will fail with &quot;invalid
      idx&quot; if you attempt to use it on a closed socket.</p>

      <p>To create a listen port, use:</p>

      <blockquote>
        <p>listen &lt;port&gt; script &lt;proc&gt;</p>
      </blockquote>

      <p>Procs should be declared as:</p>

      <blockquote>
        <p>procname &lt;newidx&gt;</p>
      </blockquote>

      <p>For example:</p>

<pre>
  listen 6687 script listen:grab

  proc listen:grab {newidx} {
    control $newidx listen:control
  }
</pre>

      <p>When a new connection arrives in port 6687, Eggdrop will create a
      new idx for the connection. That idx is sent to &#39;listen:grab&#39;.
      The proc immediately puts this idx under control. Once
      &#39;listen:grab&#39; has been called, the idx behaves exactly like
      an outgoing connection would.</p>

      <p>The best way to learn how to use these commands is to find a
      script that uses them and follow it carefully. However, hopefully
      this has given you a good start.</p>
    </blockquote>

    <p><a name="matchchars"></a>14. <strong>Match characters</strong></p>

    <blockquote>
      <p>Many of the bindings allow match characters in the arguments. Here
      are the four special characters:</p>

      <table>
        <tr valign="top">
          <td>
            <p><strong>?</strong></p>
          </td>

          <td>
            <p>matches any single character</p>
          </td>
        </tr>

        <tr valign="top">
          <td>
            <p><strong>*</strong></p>
          </td>

          <td>
            <p>matches 0 or more characters of any type</p>
          </td>
        </tr>

        <tr valign="top">
          <td>
            <p><strong>%</strong></p>
          </td>

          <td>
            <p>matches 0 or more non-space characters (can be used to match
            a single word)</p>
          </td>
        </tr>

        <tr valign="top">
          <td>
            <p><strong>~</strong></p>
          </td>

          <td>
            <p>matches 1 or more space characters (can be used for whitespace
            between words)</p>
          </td>
        </tr>
      </table>
    </blockquote>
    <hr>

    <p><em>Copyright &copy; 1997 Robey Pointer<br>
    Copyright &copy; 1999, 2000, 2001, 2002, 2003, 2004
    <a href="http://www.eggheads.org/"> Eggheads Development Team</a></em></p>
  </body>
</html>
